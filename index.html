<!DOCTYPE html>
<html lang="ko">
<head>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta charset="UTF-8" />
  <title>지도시스템</title>
  <script src="https://cdn.jsdelivr.net/npm/xlsx/dist/xlsx.full.min.js"></script>
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet.fullscreen/Control.FullScreen.css" />
  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
  <script src="https://unpkg.com/leaflet.fullscreen/Control.FullScreen.js"></script>
  <style>

    /* ✨ 모든 요소에 box-sizing: border-box 적용 */
    *, *::before, *::after {
      box-sizing: border-box;
    }

    /* ... (기존 CSS 스타일) ... */

    body {
      display: flex;
      gap: 20px;
      padding: 20px;
      font-family: Arial, sans-serif;
      height: 100vh;
      overflow-y: auto; /* ✨ 스크롤 기능 추가 */
    }

    #left-container {
      flex: 1 1 45%;
      display: flex;
      flex-direction: column;
      gap: 20px;
      overflow-y: auto;
      border: 1px solid #ccc;
      padding: 15px;
      border-radius: 8px;
      max-height: 100vh;
    }

    #right-container {
      flex: 1 1 55%;
      display: flex;
      flex-direction: column;
      border: 1px solid #ccc;
      padding: 15px;
      border-radius: 8px;
      max-height: 100vh;
    }

    h3, h4 {
      margin: 20px 0 10px 0;
    }

    table {
      border-collapse: collapse;
      width: 100%;
      table-layout: fixed;
    }

    thead th {
      border: 1px solid #999;
      padding: 6px 10px;
      text-align: center;
      background: #f0f0f0;
      font-weight: bold;
      word-break: break-word;
    }

    tbody td {
      border: 1px solid #999;
      padding: 6px 10px;
      word-break: break-word;
      text-align: center;
      cursor: pointer;
    }

    tbody tr:hover {
      background-color: #eef;
    }

    .table-body-wrapper {
      max-height: 40vh;
      overflow-y: auto;
      border: 1px solid #999;
      border-radius: 4px;
    }

    /* 검색결과에만 높이 제한 적용 */
    .table-body-wrapper.address-table {
      max-height: 20vh;
      overflow-y: auto;
      border: 1px solid #999;
      border-radius: 4px;
    }

    /* 선택 리스트는 제한 없음 */
    .table-body-wrapper.selected-table {
      max-height: none;
      overflow-y: visible;
      border: 1px solid #999;
      border-radius: 4px;
    }

    input[type="text"], input[type="file"], button {
      margin: 4px 0;
      padding: 6px 10px;
      font-size: 14px;
      border-radius: 4px;
      border: 1px solid #999;
    }

    button {
      cursor: pointer;
      background: #007bff;
      color: white;
      border: none;
      transition: background-color 0.3s;
    }

    button:hover {
      background: #0056b3;
    }

    #map {
      flex-grow: 1;
      height: 100%; /* 부모 높이 꽉 채우기 */
      border: 1px solid #999;
      border-radius: 8px;
      min-height: 0; /* 기존 min-height 해제 */
      position: relative; /* 자식 요소의 absolute 포지셔닝을 위해 추가 */
    }

    .name-list-label {
      display: inline;
      white-space: nowrap;
      padding: 2px 6px;
      background: rgba(255,255,255,0.8);
      border-radius: 4px;
      border: 1px solid #333;
      font-weight: bold;
      font-size: 20px;
      line-height: 1.3em;
      color: black;
      pointer-events: none;
      user-select: none;
      position: absolute;
      z-index: 10;
    }

    #loading-indicator {
      display: none;
      margin: 10px 0;
      font-weight: bold;
      color: #d33;
    }

    /* 비밀번호 모달 스타일 */
    #password-modal {
      display: none;
      position: fixed;
      z-index: 10000;
      left: 0; top: 0;
      width: 100%; height: 100%;
      background: rgba(0,0,0,0.5);
      justify-content: center;
      align-items: center;
    }

    #password-modal.flex {
      display: flex;
    }

    #password-modal .modal-box {
      background: white;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.3);
      width: 300px;
      text-align: center;
    }

    #password-modal input {
      width: 100%;
      padding: 8px;
      margin-top: 10px;
      font-size: 16px;
    }

    #password-modal button {
      padding: 6px 12px;
      margin: 10px 5px 0;
      font-size: 14px;
    }

    /* 주소 변환 영역 */
    #address-convert-area {
      display: none;
      border: 2px solid #007bff;
      background-color: #e6f0ff;
      padding: 20px;
      border-radius: 10px;
      box-shadow: 0 4px 8px rgba(0,123,255,0.3);
    }

    #address-convert-area h3 {
      color: #0056b3;
      font-weight: 700;
    }

    button#clear-search-result,
    button#clear-selected {
      background-color: #f8d7da; /* 연한 분홍색 배경 */
      color: #842029; /* 진한 붉은색 글씨 */
      border: 1px solid #f5c2c7; /* 연한 붉은 테두리 */
    }

    button#clear-search-result:hover,
    button#clear-selected:hover {
      background-color: #f5c2c7; /* 약간 더 진한 분홍 배경 */
      color: #6c1a21;
    }

    /* 네비 모달 스타일 */
    .nav-modal {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background: rgba(0,0,0,0.6);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 10000;
    }
    .nav-modal.hidden {
      display: none;
    }
    .modal-content {
      background: white;
      padding: 20px 30px;
      border-radius: 10px;
      text-align: center;
      width: 340px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.5);
    }
    .modal-content h3 {
      margin-bottom: 10px;
      font-size: 18px;
    }
    .modal-content p {
      font-size: 14px;
      margin-bottom: 20px;
      word-break: break-word;
    }
    .nav-buttons button {
      margin: 5px;
      padding: 8px 12px;
      font-size: 14px;
      border: none;
      border-radius: 6px;
      background-color: #007bff;
      color: white;
      cursor: pointer;
    }
    .nav-buttons button:hover {
      background-color: #0056b3;
    }
    .nav-buttons button#nav-cancel {
      background-color: #ccc;
      color: #333;
    }

    /* 각 컬럼 너비 고정 */
    #address-table thead th:nth-child(1), #selected-table thead th:nth-child(1) { width: 30%; }
    #address-table thead th:nth-child(2), #selected-table thead th:nth-child(2) { width: 40%; }
    #address-table thead th:nth-child(3), #selected-table thead th:nth-child(3) { width: 15%; }
    #address-table thead th:nth-child(4), #selected-table thead th:nth-child(4) { width: 15%; }

    /* 모바일 대응 */
    @media (max-width: 768px) {
      body {
        flex-direction: column;
        padding: 10px;
        height: 100vh;
      }
      #right-container {
        order: -1; /* 지도를 위로 올림 */
        height: 50vh; /* 지도 영역 높이 고정 */
        padding: 10px;
      }
      #right-container, #left-container {
        flex: none;
        width: 100%;
        max-height: none;
        height: auto;
      }
      #map {
        height: 100%; /* 부모 높이 꽉 채움 */
        min-height: 400px;
      }
    }

    /* ✨ 지도 화면 외곽 마커 지표 (Offscreen Indicator) 스타일 */
    #offscreen-indicators-container {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none; /* 지표 클릭을 방지하여 아래 지도 클릭 가능하게 함 */
        z-index: 9999; /* 다른 요소 위에 표시 */
    }

    .offscreen-indicator {
        position: absolute;
        width: 60px; /* 크기 증가 */
        height: 60px; /* 크기 증가 */
        background-color: rgba(0, 0, 255, 0.7); /* 파란색, 반투명 */
        border-radius: 50%; /* 원형 */
        transform: translate(-50%, -50%); /* 지표 중앙 정렬 */
        display: flex;
        flex-direction: column; /* 세로로 화살표와 텍스트를 정렬 */
        justify-content: center;
        align-items: center;
        color: white;
        font-weight: bold;
        cursor: pointer;
        pointer-events: auto;
        box-shadow: 0 0 5px rgba(0,0,0,0.5);
        padding: 2px; /* 내부 패딩 */
        text-align: center; /* 텍스트 중앙 정렬 */
        overflow: hidden; /* 넘치는 텍스트 숨김 */
    }
    .offscreen-indicator:hover {
        background-color: rgba(0, 0, 255, 1); /* 호버 시 진해짐 */
    }
    .offscreen-indicator .arrow-icon {
        font-size: 20px; /* 화살표 아이콘 크기 */
        line-height: 1; /* 라인 높이 조절 */
        margin-bottom: 2px; /* 화살표와 이름 사이 간격 */
    }
    .offscreen-indicator .marker-name-text {
        font-size: 10px; /* 마커 이름 텍스트 크기 */
        line-height: 1.2; /* 라인 높이 조절 */
        word-break: break-all; /* 긴 이름도 줄바꿈 허용 */
        white-space: normal; /* 텍스트 줄바꿈 허용 */
        max-height: 2.4em; /* 최대 2줄 표시 */
        overflow: hidden;
        text-overflow: ellipsis; /* 넘치는 텍스트에 ... 표시 */
    }

  </style>
</head>
<body>
  <div id="left-container">
    <div class="container" id="address-convert-area">
      <h3>📁 주소만 있는 엑셀 업로드 → 위도경도 변환 후 다운로드</h3>
      <input type="file" id="input-excel-addr" accept=".xlsx,.xls" />
      <button id="convert-download">변환 후 엑셀 다운로드</button>
      <div id="loading-indicator">주소 변환 중... 잠시만 기다려 주세요.</div>
    </div>

    <div class="container" style="flex-grow: 1; display: flex; flex-direction: column;">
      <h3>📁 좌표 포함 엑셀 업로드 + 검색</h3>
      <input type="file" id="input-excel" accept=".xlsx,.xls" />
      <input type="text" id="search-input" placeholder="🔍 업체명 검색" />

      <button id="load-from-api">📡 API에서 업체 목록 가져오기</button>

      <h4>검색 결과 (클릭하여 선택)</h4>
      <button id="select-all-search-results">검색결과 일괄 추가(선택된 리스트에 추가)</button>
      <button id="clear-search-result">검색결과 초기화</button>
      <div class="table-body-wrapper address-table">
        <table id="address-table">
          <thead>
            <tr>
              <th>업체명</th>
              <th>주소</th>
              <th style="display:none;">위도</th> <th style="display:none;">경도</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
      </div>

      <h4>선택된 리스트 (클릭하면 삭제)</h4>
      <button id="download-selected">선택 리스트 엑셀 다운로드</button>
      <button id="clear-selected">선택 리스트 초기화</button>
      <div class="table-body-wrapper selected-table">
        <table id="selected-table">
          <thead>
            <tr>
              <th>업체명</th>
              <th>주소</th>
              <th style="display:none;">위도</th> <th style="display:none;">경도</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
      </div>
    </div>
  </div>

  <div id="right-container">
    <h3>📍 지도</h3>
    <button id="locate-btn" style="margin-bottom:10px;">내 위치 표시</button>
    <button id="toggle-offscreen-markers" style="margin-bottom:10px;">화면 밖 마커 숨기기</button>
    <div id="map">
      <div id="offscreen-indicators-container"></div>
    </div>
  </div>

  <div id="password-modal">
    <div class="modal-box">
      <h3>비밀번호 입력</h3>
      <input type="password" id="password-input" placeholder="비밀번호 입력" />
      <p id="password-error" style="color: red; display: none; margin-top: 5px;">비밀번호가 틀렸습니다.</p>
      <button id="password-submit">확인</button>
      <button id="password-cancel">취소</button>
    </div>
  </div>

  <div id="nav-modal" class="nav-modal hidden">
    <div class="modal-content">
      <h3>길찾기 앱 선택</h3>
      <p id="nav-target-text"></p>
      <div class="nav-buttons">
        <button id="nav-naver">네이버 지도</button>
        <button id="nav-tmap">티맵</button>
        <button id="nav-cancel">취소</button>
      </div>
    </div>
  </div>


  <script>
      let polylineLayer = null;
      let navTargetName = "";
      let navTargetAddress = "";

      // 내회사 위치
      const myCompany = {
        name: "칼라정보기술",
        address: "경기도 수원시 영통구 신원로 55",
        lat: 37.2487505616809,
        lng: 127.047853564414
      };

      // 좌표 포함 데이터, 선택된 데이터
      let fullData = [];
      let selectedData = [];

      // 주소만 변환용 데이터
      let addrOnlyData = [];

      // UI 요소
      const inputExcel = document.getElementById('input-excel');
      const searchInput = document.getElementById('search-input');
      const tbody = document.querySelector('#address-table tbody');
      const selectedTbody = document.querySelector('#selected-table tbody');
      const downloadBtn = document.getElementById('download-selected');

      const inputExcelAddr = document.getElementById('input-excel-addr');
      const convertBtn = document.getElementById('convert-download');
      const loadingIndicator = document.getElementById('loading-indicator');

      // 비밀번호 모달 관련 요소
      const passwordModal = document.getElementById('password-modal');
      const passwordInput = document.getElementById('password-input');
      const passwordSubmit = document.getElementById('password-submit');
      const passwordCancel = document.getElementById('password-cancel');
      const passwordError = document.getElementById('password-error');

      // ✨ API에서 데이터 가져오기 버튼 요소
      const loadFromApiBtn = document.getElementById('load-from-api');

      // 올바른 비밀번호 설정
      const correctPassword = '123123'; // 원하는 비밀번호로 변경

      // ✨ 초성을 분리하기 위한 상수 (유니코드 기준)
      const CHO_SUNG = [
          'ㄱ', 'ㄲ', 'ㄴ', 'ㄷ', 'ㄸ', 'ㄹ', 'ㅁ', 'ㅂ', 'ㅃ', 'ㅅ', 'ㅆ', 'ㅇ', 'ㅈ', 'ㅉ', 'ㅊ', 'ㅋ', 'ㅌ', 'ㅍ', 'ㅎ'
      ];

      /**
       * 주어진 한글 문자열을 초성 문자열로 변환합니다.
       * 한글 음절이 아닌 문자는 그대로 반환합니다.
       * @param {string} str - 초성으로 변환할 문자열 (한글, 영문, 숫자 등 포함 가능)
       * @returns {string} - 초성으로 변환된 문자열
       */
      function getKoreanInitialConsonants(str) {
          let result = '';
          for (let i = 0; i < str.length; i++) {
              const charCode = str.charCodeAt(i);
              if (charCode >= 0xAC00 && charCode <= 0xD7A3) { // 한글 음절 범위 (가~힣)
                  const unicode = charCode - 0xAC00;
                  const cho = Math.floor(unicode / 588); // 초성 인덱스 계산
                  result += CHO_SUNG[cho];
              } else {
                  // 한글 음절이 아닌 경우 (영문, 숫자, 특수문자 등)는 그대로 추가
                  result += str[i];
              }
          }
          return result;
      }

      // ✨ 새로운 헬퍼 함수: 입력된 문자열이 오직 한글 초성으로만 구성되었는지 확인
      function isOnlyKoreanInitials(text) {
          if (!text) return false;
          const initialConsonantCompatibilityJamoCodes = [
              0x3131, 0x3132, 0x3134, 0x3137, 0x3138, 0x3139, 0x3141, 0x3142, 0x3143,
              0x3145, 0x3146, 0x3147, 0x3148, 0x3149, 0x314A, 0x314B, 0x314C, 0x314D, 0x314E // ㄱㄲㄴㄷㄸㄹㅁㅂㅃㅅㅆㅇㅈㅉㅊㅋㅌㅍㅎ (호환용 한글 자모)
          ];
          const initialConsonantJamoCodes = [
              0x1100, 0x1101, 0x1102, 0x1103, 0x1104, 0x1105, 0x1106, 0x1107, 0x1108,
              0x1109, 0x110A, 0x110B, 0x110C, 0x110D, 0x110E, 0x110F, 0x1110, 0x1111, 0x1112 // ᄀᄁᄂᄃᄄᄅᄆᄇᄈᄉᄊᄋᄌᄍᄎᄏᄐᄑᄒ (한글 자모)
          ];

          for (let i = 0; i < text.length; i++) {
              const charCode = text.charCodeAt(i);

              // 1. 전체 한글 음절(가-힣)이 포함되어 있다면 초성으로만 구성된 것이 아님
              if (charCode >= 0xAC00 && charCode <= 0xD7A3) {
                  return false;
              }
              // 2. 한글 자모 또는 호환용 한글 자모인데 초성이 아니라면 초성으로만 구성된 것이 아님
              else if (
                  (charCode >= 0x3130 && charCode <= 0x318F && !initialConsonantCompatibilityJamoCodes.includes(charCode)) || // 호환용 자모이면서 초성이 아님 (예: ㅏ, ㅂ)
                  (charCode >= 0x1100 && charCode <= 0x11FF && !initialConsonantJamoCodes.includes(charCode)) // 한글 자모이면서 초성이 아님
              ) {
                  return false;
              }
              // 3. 한글 관련 문자(초성 자모, 음절)가 아닌 다른 문자(영어, 숫자, 특수문자 등)가 포함되어 있다면 초성으로만 구성된 것이 아님
              else if (!(charCode >= 0x3130 && charCode <= 0x318F) && !(charCode >= 0x1100 && charCode <= 0x11FF)) {
                  return false;
              }
          }
          return true; // 위의 어떤 조건에도 해당하지 않으면 오직 한글 초성으로만 구성됨
      }


      // 지도 초기화
      const map = L.map('map', {
        fullscreenControl: true,
        minZoom: 9,
        maxZoom: 16
      }).setView([myCompany.lat, myCompany.lng], 11);

      L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        attribution: '&copy; OpenStreetMap contributors'
      }).addTo(map);

      const markersGroup = L.layerGroup().addTo(map);

      if (!map.getPane('labelPane')) {
        map.createPane('labelPane');
        map.getPane('labelPane').style.zIndex = 650;
      }

      // 내회사 마커 (붉은 원)
      const myCompanyIcon = L.divIcon({
        className: '',
        html: `<div style="
          width: 24px;
          height: 24px;
          background: red;
          border: 3px solid white;
          border-radius: 50%;
          box-shadow: 0 0 8px 2px rgba(255,0,0,0.7);
        "></div>`,
        iconSize: [30, 30],
        iconAnchor: [15, 15],
        popupAnchor: [0, -15]
      });

      const myCompanyMarker = L.marker([myCompany.lat, myCompany.lng], {
        title: myCompany.name,
        icon: myCompanyIcon,
        zIndexOffset: 1000
      }).addTo(map);

      // 내비연결 코드
      // 모바일 환경 감지 함수
      function isMobile() {
        return window.innerWidth <= 768; // 768px 기준으로 모바일/PC 구분
      }

      // 내비연결 모달 열기
      function openNavModal(name, address) {
        console.log("openNavModal 호출됨:", name, address);
        navTargetName = name;
        navTargetAddress = address;
        document.getElementById("nav-target-text").innerHTML = `${name}<br>${address}`;
        document.getElementById("nav-modal").classList.remove("hidden");
      }

      // 네이버 내비 연결
      document.getElementById("nav-naver").addEventListener("click", () => {
        const query = encodeURIComponent(navTargetAddress || navTargetName);
        const url = `https://map.naver.com/v5/search/${query}`;
        window.open(url, "_blank");
        closeNavModal();
      });

      // 티맵 내비 연결
      document.getElementById("nav-tmap").addEventListener("click", () => {
        const query = encodeURIComponent(navTargetAddress || navTargetName);
        const name = navTargetName;
        const lat = selectedData.find(x => x.name === name)?.lat;
        const lng = selectedData.find(x => x.name === name)?.lng;

        if (isMobile()) {
          if (lat && lng) {
            // ⛳ 정확한 좌표 전달 → 티맵 앱 실행
            const url = `tmap://route?goalname=${name}&goalx=${lng}&goaly=${lat}`;
            window.location.href = url;
            closeNavModal();
          } else {
            // ❗ 좌표가 없으면 이름만 전달
            const url = `tmap://route?goalname=${name}`;
            window.location.href = url;
            closeNavModal();
          }
        } else {
          // PC는 티맵 웹 내비 없으니 네이버 지도 웹으로 우회
          const url = `https://map.naver.com/v5/search/${query}`;
          window.open(url, "_blank");
          closeNavModal();
        }
      });

      // 취소 버튼
      document.getElementById("nav-cancel").addEventListener("click", () => {
        closeNavModal();
      });

      // 모달 닫기
      function closeNavModal() {
        document.getElementById("nav-modal").classList.add("hidden");
      }

      // 마커 그룹핑 함수
      function getPixelThreshold() {
        return 30; // 픽셀 기준 (필요시 조정)
      }
      function groupMarkersByProximity(locs, map, pixelThreshold) {
        const groups = [];
        const visited = new Array(locs.length).fill(false);
        for (let i = 0; i < locs.length; i++) {
          if (visited[i]) continue;
          visited[i] = true;
          const base = locs[i];
          const basePoint = map.latLngToLayerPoint([base.lat, base.lng]);
          const group = [base];
          for (let j = i + 1; j < locs.length; j++) {
            if (visited[j]) continue;
            const comp = locs[j];
            const compPoint = map.latLngToLayerPoint([comp.lat, comp.lng]);
            if (basePoint.distanceTo(compPoint) <= pixelThreshold) {
              visited[j] = true;
              group.push(comp);
            }
          }
          groups.push(group);
        }
        return groups;
      }

      // 데이터 테이블 렌더링
      function renderTable(data) {
        tbody.innerHTML = '';
        data.forEach(row => {
          const tr = document.createElement('tr');
          // 위도와 경도 데이터를 숨겨진 td 요소로 추가
          tr.innerHTML = `<td>${row.name}</td><td>${row.address || ''}</td><td style="display:none;">${row.lat}</td><td style="display:none;">${row.lng}</td>`;
          tr.addEventListener('click', () => addSelected(row));
          tbody.appendChild(tr);
        });
      }
      // 선택된 리스트 렌더링
      function renderSelected() {
        selectedTbody.innerHTML = '';
        selectedData.forEach((row, idx) => {
          const tr = document.createElement('tr');
          // 위도와 경도 데이터를 숨겨진 td 요소로 추가 (이 부분을 수정합니다)
          tr.innerHTML = `<td>${row.name}</td><td>${row.address || ''}</td><td style="display:none;">${row.lat.toFixed(6)}</td><td style="display:none;">${row.lng.toFixed(6)}</td>`;
          tr.addEventListener('click', () => removeSelected(idx));
          selectedTbody.appendChild(tr);
        });
        refreshMap();
        updateOffscreenIndicators(); // ✨ 선택 리스트 변경 시 지표도 업데이트
      }

      // 좌표 포함 엑셀 업로드
      inputExcel.addEventListener('change', e => {
        const file = e.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = evt => {
          const data = new Uint8Array(evt.target.result);
          const workbook = XLSX.read(data, { type: 'array' });
          const firstSheetName = workbook.SheetNames[0];
          const worksheet = workbook.Sheets[firstSheetName];
          const jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1 });
          fullData = jsonData.slice(1).map(row => ({
            name: row[0] || '',
            address: row[1] || '',
            lat: row[2] !== undefined ? parseFloat(row[2]) || 0 : 0,
            lng: row[3] !== undefined ? parseFloat(row[3]) || 0 : 0
          }));
          renderTable(fullData);
          saveFullDataToLocalStorage(); // ✨ 로컬 스토리지에 저장
        };
        reader.readAsArrayBuffer(file);
      });

      // 검색 기능 (✨ 초성으로만 되어있으면 초성검색, 그 외는 단어검색)
      searchInput.addEventListener('input', function() {
          const keyword = this.value.trim().toLowerCase(); // 사용자 검색어

          if (!keyword) {
              renderTable(fullData); // 검색어가 없으면 전체 데이터 표시
              saveFullDataToLocalStorage();
              return;
          }

          // ✨ 검색어의 종류를 판단
          const isOnlyInitials = isOnlyKoreanInitials(keyword);

          const filtered = fullData.filter(row => {
              const name = row.name ? row.name.toLowerCase() : ''; // 업체명 (name)

              if (isOnlyInitials) {
                  // 검색어가 초성으로만 구성되어 있으면 초성 검색 수행
                  const nameInitials = getKoreanInitialConsonants(name); // 업체명의 초성
                  const keywordInitials = getKoreanInitialConsonants(keyword); // 사용자 검색어의 초성
                  return nameInitials.includes(keywordInitials); // 업체명의 초성에 검색어 초성 포함
              } else {
                  // 검색어가 초성이 아닌 일반 단어이거나 다른 문자가 포함되어 있으면 단어 검색 수행
                  return name.includes(keyword); // 업체명에 원본 검색어 포함
              }
          });

          renderTable(filtered); // 필터링된 데이터로 테이블 갱신
          saveFullDataToLocalStorage();
      });

      // ✨ 배열을 무작위로 섞는 Fisher-Yates (Knuth) 셔플 알고리즘
      function shuffleArray(array) {
          for (let i = array.length - 1; i > 0; i--) {
              const j = Math.floor(Math.random() * (i + 1));
              [array[i], array[j]] = [array[j], array[i]]; // 요소 교환
          }
      }

      // 지도 갱신
      async function refreshMap() {
          markersGroup.clearLayers();
          myCompanyMarker.addTo(map);

          if (window.labelLinesGroup) {
            window.labelLinesGroup.clearLayers();
          } else {
            window.labelLinesGroup = L.layerGroup().addTo(map);
          }

          if (polylineLayer) {
              map.removeLayer(polylineLayer);
              polylineLayer = null;
          }

          const zoom = map.getZoom();
          const threshold = getPixelThreshold(zoom);
          const grouped = groupMarkersByProximity(selectedData, map, threshold);

          const baseOffset = 15; // 마커에서 라벨의 초기 오프셋 (픽셀)
          const labelMoveStep = 20; // 8방향 탐색 시 라벨을 이동시킬 픽셀 간격
          const maxOverlapIterations = 100; // 겹침 해결 시도 최대 반복 횟수

          const markersWithPos = []; // 라벨 마커, 현재 화면 상 위치, 크기, 원본 LatLng 정보를 저장
          const realMarkerPixelBounds = []; // 모든 실제 마커의 픽셀 경계 (피해야 할 영역)를 저장할 배열

          for (const group of grouped) {
              const popupContent = group.map(item => `
                <div class="nav-link"
                    data-name="${item.name}"
                    data-address="${item.address || ''}"
                    style="cursor:pointer; color:#007bff; font-weight:bold;">
                  ${item.name}<br/>
                  <span>${item.address || '주소 없음'}</span>
                </div>
              `).join('<hr>');

              const base = group[0];
              const baseLatLng = L.latLng(base.lat, base.lng);

              const realMarker = L.marker(baseLatLng).addTo(markersGroup);
              realMarker.bindPopup(popupContent);

              realMarker.on('popupopen', (e) => {
                const popupEl = e.popup.getElement();
                popupEl.querySelectorAll('.nav-link').forEach(el => {
                  el.addEventListener('click', () => {
                    const name = el.getAttribute('data-name');
                    const address = el.getAttribute('data-address');
                    openNavModal(name, address);
                  });
                });
              });

              // 실제 마커의 픽셀 경계 계산 및 저장
              const defaultMarkerIconSize = L.point(25, 41);
              const defaultMarkerIconAnchor = L.point(12, 41);
              const realMarkerPixelPos = map.latLngToLayerPoint(baseLatLng);
              const realMarkerTopLeft = realMarkerPixelPos.subtract(defaultMarkerIconAnchor);
              realMarkerPixelBounds.push(L.bounds(realMarkerTopLeft, realMarkerTopLeft.add(defaultMarkerIconSize)));


              const html = group.map(i => i.name).join('<br />');
              const labelIconAnchor = L.point(0, 20); // 커스텀 DivIcon의 앵커 포인트
              const icon = L.divIcon({
                className: 'name-list-label',
                html,
                iconSize: null,
                iconAnchor: labelIconAnchor // 정의된 앵커 사용
              });

              let pos = map.latLngToLayerPoint(baseLatLng).add([baseOffset, 0]);
              const labelMarker = L.marker(map.layerPointToLatLng(pos), {
                icon,
                interactive: true,
                pane: 'labelPane'
              }).addTo(markersGroup);

              labelMarker.bindPopup(popupContent);

              labelMarker.on('popupopen', (e) => {
                const popupEl = e.popup.getElement();
                popupEl.querySelectorAll('.nav-link').forEach(el => {
                  el.addEventListener('click', () => {
                    const name = el.getAttribute('data-name');
                    const address = el.getAttribute('data-address');
                    openNavModal(name, address);
                  });
                });
              });

              await new Promise(resolve => {
                  const checkElement = () => {
                      const el = labelMarker.getElement();
                      if (el) {
                          markersWithPos.push({
                              marker: labelMarker,
                              initialPos: pos.clone(),
                              pos,
                              width: el.offsetWidth,
                              height: el.offsetHeight,
                              originalLatLng: baseLatLng,
                              labelIconAnchor: labelIconAnchor
                          });
                          resolve();
                      } else {
                          setTimeout(checkElement, 10);
                      }
                  };
                  checkElement();
              });
          }

          const directions = [
              L.point(1, 0),    // 오른쪽
              L.point(1, -1),   // 오른쪽 위
              L.point(0, -1),   // 위
              L.point(-1, -1),  // 왼쪽 위
              L.point(-1, 0),   // 왼쪽
              L.point(-1, 1),   // 왼쪽 아래
              L.point(0, 1),    // 아래
              L.point(1, 1)     // 오른쪽 아래
          ];

          let overlapped = true;
          let iteration = 0;

          while (overlapped && iteration < maxOverlapIterations) {
              overlapped = false;
              // ✨ 매 반복마다 라벨 처리 순서를 무작위로 섞음
              shuffleArray(markersWithPos);

              for (let i = 0; i < markersWithPos.length; i++) {
                  const currentLabel = markersWithPos[i];

                  const currentLabelTopLeft = currentLabel.pos.subtract(currentLabel.labelIconAnchor);
                  const currentBounds = L.bounds(currentLabelTopLeft, currentLabelTopLeft.add([currentLabel.width, currentLabel.height]));

                  let hasOverlap = false;

                  // 다른 라벨들과의 겹침 확인
                  for (let j = 0; j < markersWithPos.length; j++) {
                      if (i === j) continue;

                      const otherLabel = markersWithPos[j];
                      const otherLabelTopLeft = otherLabel.pos.subtract(otherLabel.labelIconAnchor);
                      const otherBounds = L.bounds(otherLabelTopLeft, otherLabelTopLeft.add([otherLabel.width, otherLabel.height]));

                      if (currentBounds.intersects(otherBounds)) {
                          hasOverlap = true;
                          overlapped = true;
                          break;
                      }
                  }

                  // 실제 마커(obstacle)와의 겹침 확인
                  if (!hasOverlap) {
                      for (let k = 0; k < realMarkerPixelBounds.length; k++) {
                          const realMarkerBounds = realMarkerPixelBounds[k];
                          if (currentBounds.intersects(realMarkerBounds)) {
                              hasOverlap = true;
                              overlapped = true;
                              break;
                          }
                      }
                  }

                  if (hasOverlap) {
                      let foundSpot = false;
                      const basePixelPos = map.latLngToLayerPoint(currentLabel.originalLatLng);

                      for (const dir of directions) {
                          const proposedPos = basePixelPos.add(dir.multiplyBy(baseOffset + labelMoveStep * iteration));

                          const proposedLabelTopLeft = proposedPos.subtract(currentLabel.labelIconAnchor);
                          const proposedBounds = L.bounds(proposedLabelTopLeft, proposedLabelTopLeft.add([currentLabel.width, currentLabel.height]));

                          let conflict = false;

                          // 제안된 위치가 다른 라벨과 겹치는지 확인
                          for (let k = 0; k < markersWithPos.length; k++) {
                              if (i === k) continue;
                              const existingLabel = markersWithPos[k];
                              const existingLabelTopLeft = existingLabel.pos.subtract(existingLabel.labelIconAnchor);
                              const existingBounds = L.bounds(existingLabelTopLeft, existingLabelTopLeft.add([existingLabel.width, existingLabel.height]));

                              if (proposedBounds.intersects(existingBounds)) {
                                  conflict = true;
                                  break;
                              }
                          }

                          // 제안된 위치가 실제 마커(obstacle)와 겹치는지 확인
                          if (!conflict) {
                              for (let k = 0; k < realMarkerPixelBounds.length; k++) {
                                  const realMarkerBounds = realMarkerPixelBounds[k];
                                  if (proposedBounds.intersects(realMarkerBounds)) {
                                      conflict = true;
                                      break;
                                  }
                              }
                          }

                          if (!conflict) {
                              currentLabel.pos = proposedPos;
                              foundSpot = true;
                              break;
                          }
                      }
                  }
              }
              iteration++;
              await new Promise(r => setTimeout(r, 0));
          }

          window.labelLinesGroup.clearLayers();

          markersWithPos.forEach(({ marker, pos, originalLatLng, width, height, labelIconAnchor }) => {
              const labelTopLeftPixel = pos.subtract(labelIconAnchor);
              const labelCenterPixel = labelTopLeftPixel.add([width / 2, height / 2]);
              const labelCenterLatLng = map.layerPointToLatLng(labelCenterPixel);

              const line = L.polyline([originalLatLng, labelCenterLatLng], {
                  color: 'blue',
                  weight: 3,
                  pane: 'overlayPane'
              });
              window.labelLinesGroup.addLayer(line);

              const labelLatLng = map.layerPointToLatLng(pos);
              marker.setLatLng(labelLatLng);
          });
      }

      // ✨ 화면 밖 마커 지표 관련 변수 및 함수
      let offscreenIndicators = {}; // Key: marker's unique ID, Value: indicator element
      const offscreenIndicatorsContainer = document.getElementById('offscreen-indicators-container'); // 컨테이너 요소 가져오기
      const toggleOffscreenMarkersBtn = document.getElementById('toggle-offscreen-markers'); // 토글 버튼 가져오기

      function updateOffscreenIndicators() {
          // offscreen-indicators-container가 숨겨져 있으면 업데이트 로직 실행하지 않음
          if (offscreenIndicatorsContainer.style.display === 'none') {
              // 현재 보이는 모든 지표를 제거하여 깨끗하게 유지
              Object.values(offscreenIndicators).forEach(indicator => indicator.remove());
              offscreenIndicators = {};
              return;
          }

          const mapBounds = map.getBounds();
          const mapContainer = map.getContainer(); // 지도의 HTML 컨테이너 요소
          const mapRect = mapContainer.getBoundingClientRect(); // 지도의 현재 크기 및 위치
          const mapWidth = mapRect.width;
          const mapHeight = mapRect.height;

          // 지도의 중심점의 픽셀 좌표
          const centerPoint = map.latLngToContainerPoint(map.getCenter());

          if (!offscreenIndicatorsContainer) {
              console.error("Offscreen indicators container not found.");
              return;
          }

          // 현재 화면에 보이는 마커들의 ID를 추적하여 필요 없는 지표 제거에 사용
          const visibleMarkerIds = new Set();

          selectedData.forEach(marker => {
              const markerLatLng = L.latLng(marker.lat, marker.lng);
              // 마커의 고유 ID (이름, 위도, 경도 조합)
              const markerId = marker.name + '_' + marker.lat + '_' + marker.lng;

              // 마커가 현재 지도 화면 밖에 있는지 확인
              if (!mapBounds.contains(markerLatLng)) {
                  visibleMarkerIds.add(markerId); // 지표가 필요한 마커로 표시

                  let indicator = offscreenIndicators[markerId];

                  if (!indicator) {
                      // 지표가 없으면 새로 생성
                      indicator = document.createElement('div');
                      indicator.className = 'offscreen-indicator';
                      indicator.title = marker.name; // 마우스 오버 시 마커 이름 표시
                      offscreenIndicatorsContainer.appendChild(indicator);
                      offscreenIndicators[markerId] = indicator;

                      // ✨ 클릭 이벤트 리스너 추가: 내비게이션 모달 열기
                      indicator.addEventListener('click', () => {
                          openNavModal(marker.name, marker.address);
                      });
                  }

                  // 마커의 픽셀 좌표 (지도 컨테이너 기준)
                  const markerContainerPoint = map.latLngToContainerPoint(markerLatLng);

                  // 지도 중심에서 마커까지의 벡터
                  const dx = markerContainerPoint.x - centerPoint.x;
                  const dy = markerContainerPoint.y - centerPoint.y;

                  // 벡터의 각도 (라디안) 계산
                  const angle = Math.atan2(dy, dx);

                  // CSS rotation (▶ points right by default)
                  const rotationDegrees = angle * (180 / Math.PI);

                  let intersectionX, intersectionY;
                  let minT = Infinity;

                  // Helper function to calculate t and validate it for a given boundary
                  const calculateT = (numerator, denominator) => {
                      // 0으로 나누는 경우 방지 (평행한 경우)
                      if (denominator === 0) return Infinity;
                      const t_val = numerator / denominator;
                      // 중심에서 멀어지는 방향의 t 값만 유효 (음수는 뒤쪽)
                      if (t_val >= 0) return t_val;
                      return Infinity;
                  };

                  // 수직 경계 (왼쪽/오른쪽)와 교차점 확인
                  let t_x_left = calculateT(0 - centerPoint.x, dx);
                  let t_x_right = calculateT(mapWidth - centerPoint.x, dx);

                  if (t_x_left !== Infinity) {
                      const y_at_left = centerPoint.y + t_x_left * dy;
                      // 해당 교차점의 y 좌표가 유효한 범위 내에 있는지 확인
                      if (y_at_left >= 0 && y_at_left <= mapHeight) {
                          minT = Math.min(minT, t_x_left);
                      }
                  }
                  if (t_x_right !== Infinity) {
                      const y_at_right = centerPoint.y + t_x_right * dy;
                      // 해당 교차점의 y 좌표가 유효한 범위 내에 있는지 확인
                      if (y_at_right >= 0 && y_at_right <= mapHeight) {
                          minT = Math.min(minT, t_x_right);
                      }
                  }

                  // 수평 경계 (상단/하단)와 교차점 확인
                  let t_y_top = calculateT(0 - centerPoint.y, dy);
                  let t_y_bottom = calculateT(mapHeight - centerPoint.y, dy);

                  if (t_y_top !== Infinity) {
                      const x_at_top = centerPoint.x + t_y_top * dx;
                      // 해당 교차점의 x 좌표가 유효한 범위 내에 있는지 확인
                      if (x_at_top >= 0 && x_at_top <= mapWidth) {
                          minT = Math.min(minT, t_y_top);
                      }
                  }
                  if (t_y_bottom !== Infinity) {
                      const x_at_bottom = centerPoint.x + t_y_bottom * dx;
                      // 해당 교차점의 x 좌표가 유효한 범위 내에 있는지 확인
                      if (x_at_bottom >= 0 && x_at_bottom <= mapWidth) {
                          minT = Math.min(minT, t_y_bottom);
                      }
                  }

                  // 최종 교차점 계산
                  if (minT === Infinity) {
                      // 모든 경계와 교차하지 않는 드문 경우 (예: 마커가 지도 중심에 있거나, 선이 경계를 벗어나지 않는 경우)
                      // 이 경우, 임시로 이전의 고정 거리 클램핑 방식을 사용 (화면 중간쯤에 위치)
                      const indicatorSize = 60;
                      const halfSize = indicatorSize / 2;
                      const fallbackDistance = Math.max(mapWidth, mapHeight) * 0.45; // 화면 중간에 가깝게

                      intersectionX = centerPoint.x + fallbackDistance * Math.cos(angle);
                      intersectionY = centerPoint.y + fallbackDistance * Math.sin(angle);

                      // 최종적으로 화면 범위 내로 클램핑 (지표가 잘리지 않도록)
                      intersectionX = Math.max(halfSize, Math.min(intersectionX, mapWidth - halfSize));
                      intersectionY = Math.max(halfSize, Math.min(intersectionY, mapHeight - halfSize));

                  } else {
                      // 가장 가까운 경계 교차점을 지표의 중앙 위치로 설정
                      intersectionX = centerPoint.x + minT * dx;
                      intersectionY = centerPoint.y + minT * dy;

                      // 지표가 화면 밖으로 잘리지 않도록 최종적으로 클램핑 (지표 크기 고려)
                      const indicatorSize = 60; // CSS에 정의된 지표 크기
                      const halfSize = indicatorSize / 2;
                      intersectionX = Math.max(halfSize, Math.min(intersectionX, mapWidth - halfSize));
                      intersectionY = Math.max(halfSize, Math.min(intersectionY, mapHeight - halfSize));
                  }

                  // 지표 스타일 적용 및 내용 설정
                  indicator.style.left = `${intersectionX}px`;
                  indicator.style.top = `${intersectionY}px`;
                  indicator.style.transform = `translate(-50%, -50%)`; // 컨테이너는 중앙 정렬만 담당

                  // 화살표와 마커 이름 함께 표시
                  // ✨ 화살표 아이콘을 꼬리 달린 화살표로 변경 (➔)
                  indicator.innerHTML = `<div class="arrow-icon">➔</div><div class="marker-name-text">${marker.name}</div>`;

                  // ✨ 화살표 아이콘만 회전
                  const arrowIcon = indicator.querySelector('.arrow-icon');
                  if (arrowIcon) {
                      arrowIcon.style.transform = `rotate(${rotationDegrees}deg)`;
                  }
                  indicator.style.display = 'flex'; // 지표를 보이도록 설정
              } else {
                  // 마커가 화면 안에 있으면 해당 지표를 숨김
                  const indicator = offscreenIndicators[markerId];
                  if (indicator) {
                      indicator.style.display = 'none';
                  }
              }
          });

          // 이제 더 이상 화면 밖에 있지 않거나 (화면 안으로 들어왔거나)
          // selectedData에서 삭제된 마커의 지표를 제거
          Object.keys(offscreenIndicators).forEach(markerId => {
              if (!visibleMarkerIds.has(markerId)) {
                  if (offscreenIndicators[markerId]) {
                      offscreenIndicatorsContainer.removeChild(offscreenIndicators[markerId]);
                  }
                  delete offscreenIndicators[markerId];
              }
          });
      }

      // ✨ 화면 밖 마커 표시/숨기기 토글 기능
      toggleOffscreenMarkersBtn.addEventListener('click', () => {
          const isHidden = offscreenIndicatorsContainer.style.display === 'none';
          if (isHidden) {
              offscreenIndicatorsContainer.style.display = 'block';
              toggleOffscreenMarkersBtn.textContent = '화면 밖 마커 숨기기';
              localStorage.setItem('offscreenMarkersVisible', 'true');
          } else {
              offscreenIndicatorsContainer.style.display = 'none';
              toggleOffscreenMarkersBtn.textContent = '화면 밖 마커 표시';
              localStorage.setItem('offscreenMarkersVisible', 'false');
          }
          updateOffscreenIndicators(); // 상태 변경 후 지표 업데이트 강제 실행
      });

      // 선택 리스트 엑셀 다운로드
      downloadBtn.addEventListener('click', () => {
        if (selectedData.length === 0) {
          alert("선택된 리스트가 없습니다.");
          return;
        }
        const worksheetData = [
          ["업체명", "주소", "위도", "경도"],
          ...selectedData.map(item => [item.name, item.address, item.lat, item.lng])
        ];
        const worksheet = XLSX.utils.aoa_to_sheet(worksheetData);
        const workbook = XLSX.utils.book_new();
        XLSX.utils.book_append_sheet(workbook, worksheet, "SelectedList");
        XLSX.writeFile(workbook, "selected_list.xlsx");
      });

      // Google Geocoding API를 이용한 주소 → 위도경도 변환 함수
      async function getCoordsByAddress(address) {
        const apiKey = "AIzaSyBxaNCAfmnLjdC_qxdG3lhuRVHOh0Vii8w"; // 구글 API 키
        const url = `https://maps.googleapis.com/maps/api/geocode/json?address=${encodeURIComponent(address)}&key=${apiKey}`;

        try {
          console.log("주소 변환 요청:", address);
          const res = await fetch(url);
          console.log("응답 상태:", res.status);
          if (!res.ok) {
            console.error("API 요청 실패", res.status);
            return null;
          }
          const data = await res.json();
          console.log("응답 데이터:", data);

          if (data.status === "OK" && data.results.length > 0) {
            const location = data.results[0].geometry.location;
            return {
              lat: location.lat,
              lng: location.lng
            };
          } else {
            console.warn("주소 검색 결과 없음 또는 오류 상태:", data.status);
            return null;
          }
        } catch (e) {
          console.error("주소 변환 에러", e);
          return null;
        }
      }

      // 주소만 포함 엑셀 업로드
      inputExcelAddr.addEventListener('change', e => {
        const file = e.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = evt => {
          const data = new Uint8Array(evt.target.result);
          const workbook = XLSX.read(data, { type: 'array' });
          const firstSheetName = workbook.SheetNames[0];
          const worksheet = workbook.Sheets[firstSheetName];
          const jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1 });
          addrOnlyData = jsonData.slice(1).map(row => ({
            name: row[0] || '',
            address: row[1] || '',
            lat: 0,
            lng: 0
          }));
          alert(`주소 데이터 ${addrOnlyData.length}건 준비 완료`);
        };
        reader.readAsArrayBuffer(file);
      });

      // 변환 버튼 클릭 시 비밀번호 모달 띄우기
      convertBtn.addEventListener('click', () => {
        if (addrOnlyData.length === 0) {
          alert("주소 데이터가 없습니다.");
          return;
        }
        passwordInput.value = '';
        passwordError.style.display = 'none';
        passwordModal.classList.add('flex');
        passwordInput.focus();
      });

      // 비밀번호 확인 버튼
      passwordSubmit.addEventListener('click', async () => {
        const entered = passwordInput.value;
        if (entered === correctPassword) {
          passwordModal.classList.remove('flex');
          await convertAddressesToCoords();
        } else {
          passwordError.style.display = 'block';
          passwordInput.focus();
        }
      });

      // 비밀번호 취소 버튼
      passwordCancel.addEventListener('click', () => {
        passwordModal.classList.remove('flex');
      });

      // 엔터키 눌렀을 때 확인 처리
      passwordInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
          passwordSubmit.click();
        }
      });

      // 주소 변환 + 다운로드 함수
      async function convertAddressesToCoords() {
      loadingIndicator.style.display = 'block';

      for(let i = 0; i < addrOnlyData.length; i++) {
          const item = addrOnlyData[i];
          if (!item.address || item.address.trim() === '') {
          item.lat = 0;
          item.lng = 0;
          continue;
          }
          const coords = await getCoordsByAddress(item.address);
          if(coords) {
          item.lat = coords.lat;
          item.lng = coords.lng;
          } else {
          item.lat = 0;
          item.lng = 0;
          }
          await new Promise(r => setTimeout(r, 300)); // API 요청 속도 조절
      }

      // lat,lng가 0인 항목 제거
      const filteredData = addrOnlyData.filter(item => !(item.lat === 0 && item.lng === 0));

      const worksheetData = [
          ["업체명", "주소", "위도", "경도"],
          ...filteredData.map(item => [item.name, item.address, item.lat, item.lng])
      ];
      const worksheet = XLSX.utils.aoa_to_sheet(worksheetData);
      const workbook = XLSX.utils.book_new();
      XLSX.utils.book_append_sheet(workbook, worksheet, "ConvertedCoords");
      XLSX.writeFile(workbook, "converted_coordinates.xlsx");

      loadingIndicator.style.display = 'none';
      }
      // 지도 확대 축소 시 마커 및 라벨 재배치
      map.on('zoomend', () => {
        refreshMap();
        updateOffscreenIndicators(); // ✨ 줌 변경 시 지표도 업데이트
      });

      // ✨ 지도 이동 시 지표 업데이트
      map.on('moveend', updateOffscreenIndicators);


      // 내위치표시시
      const locateBtn = document.getElementById('locate-btn');
      let userLocationMarker = null;

      locateBtn.addEventListener('click', () => {
      if (!navigator.geolocation) {
          alert("현재 브라우저에서 위치 정보를 지원하지 않습니다.");
          return;
      }

      locateBtn.disabled = true;
      locateBtn.textContent = "위치 탐색 중...";

      navigator.geolocation.getCurrentPosition(
          position => {
          const lat = position.coords.latitude;
          const lng = position.coords.longitude;

          if (userLocationMarker) {
              userLocationMarker.setLatLng([lat, lng]);
          } else {
              userLocationMarker = L.marker([lat, lng], {
              title: "내 위치",
              icon: L.divIcon({
                  className: '',
                  html: `<div style="
                  width: 24px;
                  height: 24px;
                  background: blue;
                  border: 3px solid white;
                  border-radius: 50%;
                  box-shadow: 0 0 8px 2px rgba(0,0,255,0.7);
                  "></div>`,
                  iconSize: [60, 60], /* 변경: [30, 30] -> [60, 60] */
                  iconAnchor: [30, 30], /* 변경: [15, 15] -> [30, 30] */
                  popupAnchor: [0, -30] /* 변경: [0, -15] -> [0, -30] */
              })
              }).addTo(map).bindPopup("내 위치");
          }

          map.setView([lat, lng], 11);
          userLocationMarker.openPopup();

          locateBtn.disabled = false;
          locateBtn.textContent = "내 위치 표시";
          updateOffscreenIndicators(); // ✨ 내 위치 표시 후 지표도 업데이트
          },
          error => {
          alert("위치 정보를 가져오는 데 실패했습니다: " + error.message);
          locateBtn.disabled = false;
          locateBtn.textContent = "내 위치 표시";
          }
      );
      });

      // 로컬스토리지 저장 함수
      function saveSelectedToLocalStorage() {
      localStorage.setItem('selectedData', JSON.stringify(selectedData));
      }

      // 로컬스토리지 불러오기 함수
      function loadSelectedFromLocalStorage() {
      const stored = localStorage.getItem('selectedData');
      if (stored) {
          try {
          const parsed = JSON.parse(stored);
          if (Array.isArray(parsed)) {
              selectedData = parsed;
              renderSelected();
          }
          } catch (e) {
          console.error("로컬스토리지 파싱 오류", e);
          }
      }
      }

      // 선택 리스트 초기화 버튼
      document.getElementById('clear-selected').addEventListener('click', () => {
        if (confirm("선택된 리스트를 모두 삭제하시겠습니까?")) {
            selectedData = [];
            renderSelected();
            localStorage.removeItem('selectedData');
            updateOffscreenIndicators(); // ✨ 초기화 후 지표도 업데이트
        }
      });

      //수정된 add/removeSelected 함수(로컬스토리지 저장)
      function addSelected(row) {
        if (!selectedData.some(item => item.name === row.name && item.lat === row.lat && item.lng === row.lng)) {
            selectedData.push(row);
            renderSelected();
            saveSelectedToLocalStorage(); // 저장
        }
      }
      function removeSelected(idx) {
        selectedData.splice(idx, 1);
        renderSelected();
        saveSelectedToLocalStorage(); // 저장
      }

      // 검색결과 로컬스토리지 저장
      function saveFullDataToLocalStorage() {
        localStorage.setItem('fullData', JSON.stringify(fullData));
      }

      // 검색결과 로컬스토리지 불러오기
      function loadFullDataFromLocalStorage() {
        const stored = localStorage.getItem('fullData');
        if (stored) {
          try {
            const parsed = JSON.parse(stored);
            if (Array.isArray(parsed)) {
              fullData = parsed;
              renderTable(fullData);
            }
          } catch (e) {
            console.error("fullData 파싱 오류", e);
          }
        }
      }

      // 검색결과 초기화 버튼 이벤트
      document.getElementById('clear-search-result').addEventListener('click', () => {
        if (confirm("검색 결과를 초기화하시겠습니까?")) {
          fullData = [];
          renderTable(fullData);
          localStorage.removeItem('fullData');
        }
      });

      // 엑셀 업로드 후 렌더링 및 저장
      inputExcel.addEventListener('change', e => {
        const file = e.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = evt => {
          const data = new Uint8Array(evt.target.result);
          const workbook = XLSX.read(data, { type: 'array' });
          const firstSheetName = workbook.SheetNames[0];
          const worksheet = workbook.Sheets[firstSheetName];
          const jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1 });
          fullData = jsonData.slice(1).map(row => ({
            name: row[0] || '',
            address: row[1] || '',
            lat: row[2] !== undefined ? parseFloat(row[2]) || 0 : 0,
            lng: row[3] !== undefined ? parseFloat(row[3]) || 0 : 0
          }));
          renderTable(fullData);
          saveFullDataToLocalStorage();
        };
        reader.readAsArrayBuffer(file);
      });

      document.getElementById('select-all-search-results').addEventListener('click', () => {
        // 현재 주소 테이블에 보이는 데이터(=검색결과) 기준으로 전체 선택 리스트에 추가
        const rows = tbody.querySelectorAll('tr');
        rows.forEach(tr => {
          const cells = tr.children;
          const rowData = {
            name: cells[0].textContent,
            address: cells[1].textContent,
            lat: parseFloat(cells[2].textContent), // 위도 데이터 가져오기
            lng: parseFloat(cells[3].textContent)  // 경도 데이터 가져오기
          };
          // 중복 확인 후 추가
          if (!selectedData.some(item => item.name === rowData.name && item.lat === rowData.lat && item.lng === rowData.lng)) {
            selectedData.push(rowData);
          }
        });
        renderSelected();
        saveSelectedToLocalStorage();
      });

      // ✨ API에서 데이터를 가져오는 함수 추가
      async function fetchCompaniesFromAPI() {
          const apiURL = 'http://jamdolyung90.dothome.co.kr/api/companies.php'; // 실제 API 엔드포인트 주소
          loadingIndicator.textContent = 'API에서 데이터 로딩 중...';
          loadingIndicator.style.display = 'block';

          try {
              const response = await fetch(apiURL);
              if (!response.ok) {
                  throw new Error(`HTTP error! status: ${response.status}`);
              }
              const result = await response.json();

              if (result.status === 'success') {
                  // API에서 가져온 데이터로 fullData를 업데이트합니다.
                  // API 응답 데이터는 DB에서 가져온 그대로이므로, lat/lng를 float으로 변환해줍니다.
                  fullData = result.data.map(item => ({
                      name: item.name,
                      address: item.address,
                      lat: parseFloat(item.latitude),
                      lng: parseFloat(item.longitude)
                  }));
                  renderTable(fullData);
                  saveFullDataToLocalStorage(); // 로컬 스토리지에 저장
                  alert(`API에서 ${fullData.length}건의 업체 목록을 성공적으로 불러왔습니다.`);
              } else {
                  alert(`API 오류: ${result.message}`);
                  console.error('API Error:', result.message);
              }
          } catch (error) {
              alert('API에서 데이터를 가져오는 중 오류가 발생했습니다: ' + error.message);
              console.error('Fetch Error:', error);
          } finally {
              loadingIndicator.style.display = 'none';
          }
      }

      // ✨ "API에서 업체 목록 가져오기" 버튼 이벤트 리스너 추가
      loadFromApiBtn.addEventListener('click', fetchCompaniesFromAPI);


      window.addEventListener('DOMContentLoaded', () => {
        // 로컬스토리지에서 선택된 리스트 및 전체 리스트 불러오기
        loadSelectedFromLocalStorage();
        loadFullDataFromLocalStorage();

        // 모바일 여부 확인 (가로폭 768px 이하)
        const isMobileDevice = window.innerWidth <= 768; // isMobile 함수와는 별개로 사용 (초기 로드 시 판단용)
        let offscreenMarkersInitiallyVisible = false; // 초기 지표 표시 여부

        // 1. 로컬 스토리지에서 이전 설정 불러오기
        const storedVisibility = localStorage.getItem('offscreenMarkersVisible');
        if (storedVisibility !== null) {
            offscreenMarkersInitiallyVisible = (storedVisibility === 'true');
        } else {
            // 2. 로컬 스토리지에 설정이 없으면 환경에 따라 기본값 설정
            offscreenMarkersInitiallyVisible = !isMobileDevice; // PC면 보이기, 모바일이면 숨기기
        }

        // 3. offscreen-indicators-container 초기 상태 설정
        if (offscreenMarkersInitiallyVisible) {
            offscreenIndicatorsContainer.style.display = 'block';
            toggleOffscreenMarkersBtn.textContent = '화면 밖 마커 숨기기';
        } else {
            offscreenIndicatorsContainer.style.display = 'none';
            toggleOffscreenMarkersBtn.textContent = '화면 밖 마커 표시';
        }


        // 모바일이고 위치 정보 사용 가능하면
        if (isMobileDevice && navigator.geolocation) { // isMobileDevice 변수 사용
          navigator.geolocation.getCurrentPosition(
            position => {
              // 현재 위치 좌표 받아오기
              const lat = position.coords.latitude;
              const lng = position.coords.longitude;

              // 지도 중심을 내 위치로 설정
              map.setView([lat, lng], 11);

              // 지도가 보이도록 강제로 크기 재계산
              map.whenReady(() => {
                map.invalidateSize();
                updateOffscreenIndicators(); // ✨ 초기 로드 시 지표 업데이트
              });

              // 내 위치 마커가 이미 있으면 위치만 이동, 없으면 새로 생성
              if (userLocationMarker) {
                userLocationMarker.setLatLng([lat, lng]);
              } else {
                userLocationMarker = L.marker([lat, lng], {
                  title: "내 위치",
                  icon: L.divIcon({
                    className: '',
                    html: `<div style="
                      width: 24px;
                      height: 24px;
                      background: blue;
                      border: 3px solid white;
                      border-radius: 50%;
                      box-shadow: 0 0 8px 2px rgba(0,0,255,0.7);
                    "></div>`,
                    iconSize: [30, 30],
                    iconAnchor: [15, 15],
                    popupAnchor: [0, -15]
                  })
                }).addTo(map).bindPopup("내 위치").openPopup();
              }
            },
            error => {
              // 위치 정보를 가져오는 데 실패하면 내 회사 위치로 이동
              console.warn("GPS 실패: 내 회사 위치로 초기화");
              map.setView([myCompany.lat, myCompany.lng], 11);
              map.whenReady(() => {
                map.invalidateSize();
                updateOffscreenIndicators(); // ✨ 초기 로드 시 지표 업데이트
              });
            }
          );
        } else {
          // 데스크탑이거나 GPS 미지원인 경우 내 회사 위치로 초기화
          map.setView([myCompany.lat, myCompany.lng], 11);
          map.whenReady(() => {
            map.invalidateSize();
            updateOffscreenIndicators(); // ✨ 초기 로드 시 지표 업데이트
          });
        }
      });

      // ✨ 화면 크기가 변경될 때마다 지도 크기를 다시 계산하여 올바르게 표시되도록 함
      window.addEventListener('resize', function() {
          map.invalidateSize();
          updateOffscreenIndicators(); // ✨ 화면 리사이즈 시 지표도 업데이트
      });
  </script>


</body>
</html>