<!DOCTYPE html>
<html lang="ko">
<head>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta charset="UTF-8" />
  <title>ì§€ë„ì‹œìŠ¤í…œ</title>
  <script src="https://cdn.jsdelivr.net/npm/xlsx/dist/xlsx.full.min.js"></script>
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet.fullscreen/Control.FullScreen.css" />
  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
  <script src="https://unpkg.com/leaflet.fullscreen/Control.FullScreen.js"></script>
  <style>

    /* âœ¨ ëª¨ë“  ìš”ì†Œì— box-sizing: border-box ì ìš© */
    *, *::before, *::after {
      box-sizing: border-box;
    }

    /* ... (ê¸°ì¡´ CSS ìŠ¤íƒ€ì¼) ... */

    body {
      display: flex;
      gap: 20px;
      padding: 20px;
      font-family: Arial, sans-serif;
      height: 100vh;
      overflow-y: auto; /* âœ¨ ìŠ¤í¬ë¡¤ ê¸°ëŠ¥ ì¶”ê°€ */
    }

    #left-container {
      flex: 1 1 45%;
      display: flex;
      flex-direction: column;
      gap: 20px;
      overflow-y: auto;
      border: 1px solid #ccc;
      padding: 15px;
      border-radius: 8px;
      max-height: 100vh;
    }

    #right-container {
      flex: 1 1 55%;
      display: flex;
      flex-direction: column;
      border: 1px solid #ccc;
      padding: 15px;
      border-radius: 8px;
      max-height: 100vh;
    }

    h3, h4 {
      margin: 20px 0 10px 0;
    }

    table {
      border-collapse: collapse;
      width: 100%;
      table-layout: fixed;
    }

    thead th {
      border: 1px solid #999;
      padding: 6px 10px;
      text-align: center;
      background: #f0f0f0;
      font-weight: bold;
      word-break: break-word;
    }

    tbody td {
      border: 1px solid #999;
      padding: 6px 10px;
      word-break: break-word;
      text-align: center;
      cursor: pointer;
    }

    tbody tr:hover {
      background-color: #eef;
    }

    .table-body-wrapper {
      max-height: 40vh;
      overflow-y: auto;
      border: 1px solid #999;
      border-radius: 4px;
    }

    /* ê²€ìƒ‰ê²°ê³¼ì—ë§Œ ë†’ì´ ì œí•œ ì ìš© */
    .table-body-wrapper.address-table {
      max-height: 20vh;
      overflow-y: auto;
      border: 1px solid #999;
      border-radius: 4px;
    }

    /* ì„ íƒ ë¦¬ìŠ¤íŠ¸ëŠ” ì œí•œ ì—†ìŒ */
    .table-body-wrapper.selected-table {
      max-height: none;
      overflow-y: visible;
      border: 1px solid #999;
      border-radius: 4px;
    }

    input[type="text"], input[type="file"], button {
      margin: 4px 0;
      padding: 6px 10px;
      font-size: 14px;
      border-radius: 4px;
      border: 1px solid #999;
    }

    button {
      cursor: pointer;
      background: #007bff;
      color: white;
      border: none;
      transition: background-color 0.3s;
    }

    button:hover {
      background: #0056b3;
    }

    #map {
      flex-grow: 1;
      height: 100%; /* ë¶€ëª¨ ë†’ì´ ê½‰ ì±„ìš°ê¸° */
      border: 1px solid #999;
      border-radius: 8px;
      min-height: 0; /* ê¸°ì¡´ min-height í•´ì œ */
      position: relative; /* ìì‹ ìš”ì†Œì˜ absolute í¬ì§€ì…”ë‹ì„ ìœ„í•´ ì¶”ê°€ */
    }

    .name-list-label {
      display: inline;
      white-space: nowrap;
      padding: 2px 6px;
      background: rgba(255,255,255,0.8);
      border-radius: 4px;
      border: 1px solid #333;
      font-weight: bold;
      font-size: 20px;
      line-height: 1.3em;
      color: black;
      pointer-events: none;
      user-select: none;
      position: absolute;
      z-index: 10;
    }

    #loading-indicator {
      display: none;
      margin: 10px 0;
      font-weight: bold;
      color: #d33;
    }

    /* ë¹„ë°€ë²ˆí˜¸ ëª¨ë‹¬ ìŠ¤íƒ€ì¼ */
    #password-modal {
      display: none;
      position: fixed;
      z-index: 10000;
      left: 0; top: 0;
      width: 100%; height: 100%;
      background: rgba(0,0,0,0.5);
      justify-content: center;
      align-items: center;
    }

    #password-modal.flex {
      display: flex;
    }

    #password-modal .modal-box {
      background: white;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.3);
      width: 300px;
      text-align: center;
    }

    #password-modal input {
      width: 100%;
      padding: 8px;
      margin-top: 10px;
      font-size: 16px;
    }

    #password-modal button {
      padding: 6px 12px;
      margin: 10px 5px 0;
      font-size: 14px;
    }

    /* ì£¼ì†Œ ë³€í™˜ ì˜ì—­ */
    #address-convert-area {
      display: none;
      border: 2px solid #007bff;
      background-color: #e6f0ff;
      padding: 20px;
      border-radius: 10px;
      box-shadow: 0 4px 8px rgba(0,123,255,0.3);
    }

    #address-convert-area h3 {
      color: #0056b3;
      font-weight: 700;
    }

    button#clear-search-result,
    button#clear-selected {
      background-color: #f8d7da; /* ì—°í•œ ë¶„í™ìƒ‰ ë°°ê²½ */
      color: #842029; /* ì§„í•œ ë¶‰ì€ìƒ‰ ê¸€ì”¨ */
      border: 1px solid #f5c2c7; /* ì—°í•œ ë¶‰ì€ í…Œë‘ë¦¬ */
    }

    button#clear-search-result:hover,
    button#clear-selected:hover {
      background-color: #f5c2c7; /* ì•½ê°„ ë” ì§„í•œ ë¶„í™ ë°°ê²½ */
      color: #6c1a21;
    }

    /* ë„¤ë¹„ ëª¨ë‹¬ ìŠ¤íƒ€ì¼ */
    .nav-modal {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background: rgba(0,0,0,0.6);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 10000;
    }
    .nav-modal.hidden {
      display: none;
    }
    .modal-content {
      background: white;
      padding: 20px 30px;
      border-radius: 10px;
      text-align: center;
      width: 340px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.5);
    }
    .modal-content h3 {
      margin-bottom: 10px;
      font-size: 18px;
    }
    .modal-content p {
      font-size: 14px;
      margin-bottom: 20px;
      word-break: break-word;
    }
    .nav-buttons button {
      margin: 5px;
      padding: 8px 12px;
      font-size: 14px;
      border: none;
      border-radius: 6px;
      background-color: #007bff;
      color: white;
      cursor: pointer;
    }
    .nav-buttons button:hover {
      background-color: #0056b3;
    }
    .nav-buttons button#nav-cancel {
      background-color: #ccc;
      color: #333;
    }

    /* ê° ì»¬ëŸ¼ ë„ˆë¹„ ê³ ì • */
    #address-table thead th:nth-child(1), #selected-table thead th:nth-child(1) { width: 30%; }
    #address-table thead th:nth-child(2), #selected-table thead th:nth-child(2) { width: 40%; }
    #address-table thead th:nth-child(3), #selected-table thead th:nth-child(3) { width: 15%; }
    #address-table thead th:nth-child(4), #selected-table thead th:nth-child(4) { width: 15%; }

    /* ëª¨ë°”ì¼ ëŒ€ì‘ */
    @media (max-width: 768px) {
      body {
        flex-direction: column;
        padding: 10px;
        height: 100vh;
      }
      #right-container {
        order: -1; /* ì§€ë„ë¥¼ ìœ„ë¡œ ì˜¬ë¦¼ */
        height: 50vh; /* ì§€ë„ ì˜ì—­ ë†’ì´ ê³ ì • */
        padding: 10px;
      }
      #right-container, #left-container {
        flex: none;
        width: 100%;
        max-height: none;
        height: auto;
      }
      #map {
        height: 100%; /* ë¶€ëª¨ ë†’ì´ ê½‰ ì±„ì›€ */
        min-height: 400px;
      }
    }

    /* âœ¨ ì§€ë„ í™”ë©´ ì™¸ê³½ ë§ˆì»¤ ì§€í‘œ (Offscreen Indicator) ìŠ¤íƒ€ì¼ */
    #offscreen-indicators-container {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none; /* ì§€í‘œ í´ë¦­ì„ ë°©ì§€í•˜ì—¬ ì•„ë˜ ì§€ë„ í´ë¦­ ê°€ëŠ¥í•˜ê²Œ í•¨ */
        z-index: 9999; /* ë‹¤ë¥¸ ìš”ì†Œ ìœ„ì— í‘œì‹œ */
    }

    .offscreen-indicator {
        position: absolute;
        width: 60px; /* í¬ê¸° ì¦ê°€ */
        height: 60px; /* í¬ê¸° ì¦ê°€ */
        background-color: rgba(0, 0, 255, 0.7); /* íŒŒë€ìƒ‰, ë°˜íˆ¬ëª… */
        border-radius: 50%; /* ì›í˜• */
        transform: translate(-50%, -50%); /* ì§€í‘œ ì¤‘ì•™ ì •ë ¬ */
        display: flex;
        flex-direction: column; /* ì„¸ë¡œë¡œ í™”ì‚´í‘œì™€ í…ìŠ¤íŠ¸ë¥¼ ì •ë ¬ */
        justify-content: center;
        align-items: center;
        color: white;
        font-weight: bold;
        cursor: pointer;
        pointer-events: auto;
        box-shadow: 0 0 5px rgba(0,0,0,0.5);
        padding: 2px; /* ë‚´ë¶€ íŒ¨ë”© */
        text-align: center; /* í…ìŠ¤íŠ¸ ì¤‘ì•™ ì •ë ¬ */
        overflow: hidden; /* ë„˜ì¹˜ëŠ” í…ìŠ¤íŠ¸ ìˆ¨ê¹€ */
    }
    .offscreen-indicator:hover {
        background-color: rgba(0, 0, 255, 1); /* í˜¸ë²„ ì‹œ ì§„í•´ì§ */
    }
    .offscreen-indicator .arrow-icon {
        font-size: 20px; /* í™”ì‚´í‘œ ì•„ì´ì½˜ í¬ê¸° */
        line-height: 1; /* ë¼ì¸ ë†’ì´ ì¡°ì ˆ */
        margin-bottom: 2px; /* í™”ì‚´í‘œì™€ ì´ë¦„ ì‚¬ì´ ê°„ê²© */
    }
    .offscreen-indicator .marker-name-text {
        font-size: 10px; /* ë§ˆì»¤ ì´ë¦„ í…ìŠ¤íŠ¸ í¬ê¸° */
        line-height: 1.2; /* ë¼ì¸ ë†’ì´ ì¡°ì ˆ */
        word-break: break-all; /* ê¸´ ì´ë¦„ë„ ì¤„ë°”ê¿ˆ í—ˆìš© */
        white-space: normal; /* í…ìŠ¤íŠ¸ ì¤„ë°”ê¿ˆ í—ˆìš© */
        max-height: 2.4em; /* ìµœëŒ€ 2ì¤„ í‘œì‹œ */
        overflow: hidden;
        text-overflow: ellipsis; /* ë„˜ì¹˜ëŠ” í…ìŠ¤íŠ¸ì— ... í‘œì‹œ */
    }

  </style>
</head>
<body>
  <div id="left-container">
    <div class="container" id="address-convert-area">
      <h3>ğŸ“ ì£¼ì†Œë§Œ ìˆëŠ” ì—‘ì…€ ì—…ë¡œë“œ â†’ ìœ„ë„ê²½ë„ ë³€í™˜ í›„ ë‹¤ìš´ë¡œë“œ</h3>
      <input type="file" id="input-excel-addr" accept=".xlsx,.xls" />
      <button id="convert-download">ë³€í™˜ í›„ ì—‘ì…€ ë‹¤ìš´ë¡œë“œ</button>
      <div id="loading-indicator">ì£¼ì†Œ ë³€í™˜ ì¤‘... ì ì‹œë§Œ ê¸°ë‹¤ë ¤ ì£¼ì„¸ìš”.</div>
    </div>

    <div class="container" style="flex-grow: 1; display: flex; flex-direction: column;">
      <h3>ğŸ“ ì¢Œí‘œ í¬í•¨ ì—‘ì…€ ì—…ë¡œë“œ + ê²€ìƒ‰</h3>
      <input type="file" id="input-excel" accept=".xlsx,.xls" />
      <input type="text" id="search-input" placeholder="ğŸ” ì—…ì²´ëª… ê²€ìƒ‰" />

      <button id="load-from-api">ğŸ“¡ APIì—ì„œ ì—…ì²´ ëª©ë¡ ê°€ì ¸ì˜¤ê¸°</button>

      <h4>ê²€ìƒ‰ ê²°ê³¼ (í´ë¦­í•˜ì—¬ ì„ íƒ)</h4>
      <button id="select-all-search-results">ê²€ìƒ‰ê²°ê³¼ ì¼ê´„ ì¶”ê°€(ì„ íƒëœ ë¦¬ìŠ¤íŠ¸ì— ì¶”ê°€)</button>
      <button id="clear-search-result">ê²€ìƒ‰ê²°ê³¼ ì´ˆê¸°í™”</button>
      <div class="table-body-wrapper address-table">
        <table id="address-table">
          <thead>
            <tr>
              <th>ì—…ì²´ëª…</th>
              <th>ì£¼ì†Œ</th>
              <th style="display:none;">ìœ„ë„</th> <th style="display:none;">ê²½ë„</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
      </div>

      <h4>ì„ íƒëœ ë¦¬ìŠ¤íŠ¸ (í´ë¦­í•˜ë©´ ì‚­ì œ)</h4>
      <button id="download-selected">ì„ íƒ ë¦¬ìŠ¤íŠ¸ ì—‘ì…€ ë‹¤ìš´ë¡œë“œ</button>
      <button id="clear-selected">ì„ íƒ ë¦¬ìŠ¤íŠ¸ ì´ˆê¸°í™”</button>
      <div class="table-body-wrapper selected-table">
        <table id="selected-table">
          <thead>
            <tr>
              <th>ì—…ì²´ëª…</th>
              <th>ì£¼ì†Œ</th>
              <th style="display:none;">ìœ„ë„</th> <th style="display:none;">ê²½ë„</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
      </div>
    </div>
  </div>

  <div id="right-container">
    <h3>ğŸ“ ì§€ë„</h3>
    <button id="locate-btn" style="margin-bottom:10px;">ë‚´ ìœ„ì¹˜ í‘œì‹œ</button>
    <button id="toggle-offscreen-markers" style="margin-bottom:10px;">í™”ë©´ ë°– ë§ˆì»¤ ìˆ¨ê¸°ê¸°</button>
    <div id="map">
      <div id="offscreen-indicators-container"></div>
    </div>
  </div>

  <div id="password-modal">
    <div class="modal-box">
      <h3>ë¹„ë°€ë²ˆí˜¸ ì…ë ¥</h3>
      <input type="password" id="password-input" placeholder="ë¹„ë°€ë²ˆí˜¸ ì…ë ¥" />
      <p id="password-error" style="color: red; display: none; margin-top: 5px;">ë¹„ë°€ë²ˆí˜¸ê°€ í‹€ë ¸ìŠµë‹ˆë‹¤.</p>
      <button id="password-submit">í™•ì¸</button>
      <button id="password-cancel">ì·¨ì†Œ</button>
    </div>
  </div>

  <div id="nav-modal" class="nav-modal hidden">
    <div class="modal-content">
      <h3>ê¸¸ì°¾ê¸° ì•± ì„ íƒ</h3>
      <p id="nav-target-text"></p>
      <div class="nav-buttons">
        <button id="nav-naver">ë„¤ì´ë²„ ì§€ë„</button>
        <button id="nav-tmap">í‹°ë§µ</button>
        <button id="nav-cancel">ì·¨ì†Œ</button>
      </div>
    </div>
  </div>


  <script>
      let polylineLayer = null;
      let navTargetName = "";
      let navTargetAddress = "";

      // ë‚´íšŒì‚¬ ìœ„ì¹˜
      const myCompany = {
        name: "ì¹¼ë¼ì •ë³´ê¸°ìˆ ",
        address: "ê²½ê¸°ë„ ìˆ˜ì›ì‹œ ì˜í†µêµ¬ ì‹ ì›ë¡œ 55",
        lat: 37.2487505616809,
        lng: 127.047853564414
      };

      // ì¢Œí‘œ í¬í•¨ ë°ì´í„°, ì„ íƒëœ ë°ì´í„°
      let fullData = [];
      let selectedData = [];

      // ì£¼ì†Œë§Œ ë³€í™˜ìš© ë°ì´í„°
      let addrOnlyData = [];

      // UI ìš”ì†Œ
      const inputExcel = document.getElementById('input-excel');
      const searchInput = document.getElementById('search-input');
      const tbody = document.querySelector('#address-table tbody');
      const selectedTbody = document.querySelector('#selected-table tbody');
      const downloadBtn = document.getElementById('download-selected');

      const inputExcelAddr = document.getElementById('input-excel-addr');
      const convertBtn = document.getElementById('convert-download');
      const loadingIndicator = document.getElementById('loading-indicator');

      // ë¹„ë°€ë²ˆí˜¸ ëª¨ë‹¬ ê´€ë ¨ ìš”ì†Œ
      const passwordModal = document.getElementById('password-modal');
      const passwordInput = document.getElementById('password-input');
      const passwordSubmit = document.getElementById('password-submit');
      const passwordCancel = document.getElementById('password-cancel');
      const passwordError = document.getElementById('password-error');

      // âœ¨ APIì—ì„œ ë°ì´í„° ê°€ì ¸ì˜¤ê¸° ë²„íŠ¼ ìš”ì†Œ
      const loadFromApiBtn = document.getElementById('load-from-api');

      // ì˜¬ë°”ë¥¸ ë¹„ë°€ë²ˆí˜¸ ì„¤ì •
      const correctPassword = '123123'; // ì›í•˜ëŠ” ë¹„ë°€ë²ˆí˜¸ë¡œ ë³€ê²½

      // âœ¨ ì´ˆì„±ì„ ë¶„ë¦¬í•˜ê¸° ìœ„í•œ ìƒìˆ˜ (ìœ ë‹ˆì½”ë“œ ê¸°ì¤€)
      const CHO_SUNG = [
          'ã„±', 'ã„²', 'ã„´', 'ã„·', 'ã„¸', 'ã„¹', 'ã…', 'ã…‚', 'ã…ƒ', 'ã……', 'ã…†', 'ã…‡', 'ã…ˆ', 'ã…‰', 'ã…Š', 'ã…‹', 'ã…Œ', 'ã…', 'ã…'
      ];

      /**
       * ì£¼ì–´ì§„ í•œê¸€ ë¬¸ìì—´ì„ ì´ˆì„± ë¬¸ìì—´ë¡œ ë³€í™˜í•©ë‹ˆë‹¤.
       * í•œê¸€ ìŒì ˆì´ ì•„ë‹Œ ë¬¸ìëŠ” ê·¸ëŒ€ë¡œ ë°˜í™˜í•©ë‹ˆë‹¤.
       * @param {string} str - ì´ˆì„±ìœ¼ë¡œ ë³€í™˜í•  ë¬¸ìì—´ (í•œê¸€, ì˜ë¬¸, ìˆ«ì ë“± í¬í•¨ ê°€ëŠ¥)
       * @returns {string} - ì´ˆì„±ìœ¼ë¡œ ë³€í™˜ëœ ë¬¸ìì—´
       */
      function getKoreanInitialConsonants(str) {
          let result = '';
          for (let i = 0; i < str.length; i++) {
              const charCode = str.charCodeAt(i);
              if (charCode >= 0xAC00 && charCode <= 0xD7A3) { // í•œê¸€ ìŒì ˆ ë²”ìœ„ (ê°€~í£)
                  const unicode = charCode - 0xAC00;
                  const cho = Math.floor(unicode / 588); // ì´ˆì„± ì¸ë±ìŠ¤ ê³„ì‚°
                  result += CHO_SUNG[cho];
              } else {
                  // í•œê¸€ ìŒì ˆì´ ì•„ë‹Œ ê²½ìš° (ì˜ë¬¸, ìˆ«ì, íŠ¹ìˆ˜ë¬¸ì ë“±)ëŠ” ê·¸ëŒ€ë¡œ ì¶”ê°€
                  result += str[i];
              }
          }
          return result;
      }

      // âœ¨ ìƒˆë¡œìš´ í—¬í¼ í•¨ìˆ˜: ì…ë ¥ëœ ë¬¸ìì—´ì´ ì˜¤ì§ í•œê¸€ ì´ˆì„±ìœ¼ë¡œë§Œ êµ¬ì„±ë˜ì—ˆëŠ”ì§€ í™•ì¸
      function isOnlyKoreanInitials(text) {
          if (!text) return false;
          const initialConsonantCompatibilityJamoCodes = [
              0x3131, 0x3132, 0x3134, 0x3137, 0x3138, 0x3139, 0x3141, 0x3142, 0x3143,
              0x3145, 0x3146, 0x3147, 0x3148, 0x3149, 0x314A, 0x314B, 0x314C, 0x314D, 0x314E // ã„±ã„²ã„´ã„·ã„¸ã„¹ã…ã…‚ã…ƒã……ã…†ã…‡ã…ˆã…‰ã…Šã…‹ã…Œã…ã… (í˜¸í™˜ìš© í•œê¸€ ìëª¨)
          ];
          const initialConsonantJamoCodes = [
              0x1100, 0x1101, 0x1102, 0x1103, 0x1104, 0x1105, 0x1106, 0x1107, 0x1108,
              0x1109, 0x110A, 0x110B, 0x110C, 0x110D, 0x110E, 0x110F, 0x1110, 0x1111, 0x1112 // á„€á„á„‚á„ƒá„„á„…á„†á„‡á„ˆá„‰á„Šá„‹á„Œá„á„á„á„á„‘á„’ (í•œê¸€ ìëª¨)
          ];

          for (let i = 0; i < text.length; i++) {
              const charCode = text.charCodeAt(i);

              // 1. ì „ì²´ í•œê¸€ ìŒì ˆ(ê°€-í£)ì´ í¬í•¨ë˜ì–´ ìˆë‹¤ë©´ ì´ˆì„±ìœ¼ë¡œë§Œ êµ¬ì„±ëœ ê²ƒì´ ì•„ë‹˜
              if (charCode >= 0xAC00 && charCode <= 0xD7A3) {
                  return false;
              }
              // 2. í•œê¸€ ìëª¨ ë˜ëŠ” í˜¸í™˜ìš© í•œê¸€ ìëª¨ì¸ë° ì´ˆì„±ì´ ì•„ë‹ˆë¼ë©´ ì´ˆì„±ìœ¼ë¡œë§Œ êµ¬ì„±ëœ ê²ƒì´ ì•„ë‹˜
              else if (
                  (charCode >= 0x3130 && charCode <= 0x318F && !initialConsonantCompatibilityJamoCodes.includes(charCode)) || // í˜¸í™˜ìš© ìëª¨ì´ë©´ì„œ ì´ˆì„±ì´ ì•„ë‹˜ (ì˜ˆ: ã…, ã…‚)
                  (charCode >= 0x1100 && charCode <= 0x11FF && !initialConsonantJamoCodes.includes(charCode)) // í•œê¸€ ìëª¨ì´ë©´ì„œ ì´ˆì„±ì´ ì•„ë‹˜
              ) {
                  return false;
              }
              // 3. í•œê¸€ ê´€ë ¨ ë¬¸ì(ì´ˆì„± ìëª¨, ìŒì ˆ)ê°€ ì•„ë‹Œ ë‹¤ë¥¸ ë¬¸ì(ì˜ì–´, ìˆ«ì, íŠ¹ìˆ˜ë¬¸ì ë“±)ê°€ í¬í•¨ë˜ì–´ ìˆë‹¤ë©´ ì´ˆì„±ìœ¼ë¡œë§Œ êµ¬ì„±ëœ ê²ƒì´ ì•„ë‹˜
              else if (!(charCode >= 0x3130 && charCode <= 0x318F) && !(charCode >= 0x1100 && charCode <= 0x11FF)) {
                  return false;
              }
          }
          return true; // ìœ„ì˜ ì–´ë–¤ ì¡°ê±´ì—ë„ í•´ë‹¹í•˜ì§€ ì•Šìœ¼ë©´ ì˜¤ì§ í•œê¸€ ì´ˆì„±ìœ¼ë¡œë§Œ êµ¬ì„±ë¨
      }


      // ì§€ë„ ì´ˆê¸°í™”
      const map = L.map('map', {
        fullscreenControl: true,
        minZoom: 9,
        maxZoom: 16
      }).setView([myCompany.lat, myCompany.lng], 11);

      L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        attribution: '&copy; OpenStreetMap contributors'
      }).addTo(map);

      const markersGroup = L.layerGroup().addTo(map);

      if (!map.getPane('labelPane')) {
        map.createPane('labelPane');
        map.getPane('labelPane').style.zIndex = 650;
      }

      // ë‚´íšŒì‚¬ ë§ˆì»¤ (ë¶‰ì€ ì›)
      const myCompanyIcon = L.divIcon({
        className: '',
        html: `<div style="
          width: 24px;
          height: 24px;
          background: red;
          border: 3px solid white;
          border-radius: 50%;
          box-shadow: 0 0 8px 2px rgba(255,0,0,0.7);
        "></div>`,
        iconSize: [30, 30],
        iconAnchor: [15, 15],
        popupAnchor: [0, -15]
      });

      const myCompanyMarker = L.marker([myCompany.lat, myCompany.lng], {
        title: myCompany.name,
        icon: myCompanyIcon,
        zIndexOffset: 1000
      }).addTo(map);

      // ë‚´ë¹„ì—°ê²° ì½”ë“œ
      // ëª¨ë°”ì¼ í™˜ê²½ ê°ì§€ í•¨ìˆ˜
      function isMobile() {
        return window.innerWidth <= 768; // 768px ê¸°ì¤€ìœ¼ë¡œ ëª¨ë°”ì¼/PC êµ¬ë¶„
      }

      // ë‚´ë¹„ì—°ê²° ëª¨ë‹¬ ì—´ê¸°
      function openNavModal(name, address) {
        console.log("openNavModal í˜¸ì¶œë¨:", name, address);
        navTargetName = name;
        navTargetAddress = address;
        document.getElementById("nav-target-text").innerHTML = `${name}<br>${address}`;
        document.getElementById("nav-modal").classList.remove("hidden");
      }

      // ë„¤ì´ë²„ ë‚´ë¹„ ì—°ê²°
      document.getElementById("nav-naver").addEventListener("click", () => {
        const query = encodeURIComponent(navTargetAddress || navTargetName);
        const url = `https://map.naver.com/v5/search/${query}`;
        window.open(url, "_blank");
        closeNavModal();
      });

      // í‹°ë§µ ë‚´ë¹„ ì—°ê²°
      document.getElementById("nav-tmap").addEventListener("click", () => {
        const query = encodeURIComponent(navTargetAddress || navTargetName);
        const name = navTargetName;
        const lat = selectedData.find(x => x.name === name)?.lat;
        const lng = selectedData.find(x => x.name === name)?.lng;

        if (isMobile()) {
          if (lat && lng) {
            // â›³ ì •í™•í•œ ì¢Œí‘œ ì „ë‹¬ â†’ í‹°ë§µ ì•± ì‹¤í–‰
            const url = `tmap://route?goalname=${name}&goalx=${lng}&goaly=${lat}`;
            window.location.href = url;
            closeNavModal();
          } else {
            // â— ì¢Œí‘œê°€ ì—†ìœ¼ë©´ ì´ë¦„ë§Œ ì „ë‹¬
            const url = `tmap://route?goalname=${name}`;
            window.location.href = url;
            closeNavModal();
          }
        } else {
          // PCëŠ” í‹°ë§µ ì›¹ ë‚´ë¹„ ì—†ìœ¼ë‹ˆ ë„¤ì´ë²„ ì§€ë„ ì›¹ìœ¼ë¡œ ìš°íšŒ
          const url = `https://map.naver.com/v5/search/${query}`;
          window.open(url, "_blank");
          closeNavModal();
        }
      });

      // ì·¨ì†Œ ë²„íŠ¼
      document.getElementById("nav-cancel").addEventListener("click", () => {
        closeNavModal();
      });

      // ëª¨ë‹¬ ë‹«ê¸°
      function closeNavModal() {
        document.getElementById("nav-modal").classList.add("hidden");
      }

      // ë§ˆì»¤ ê·¸ë£¹í•‘ í•¨ìˆ˜
      function getPixelThreshold() {
        return 30; // í”½ì…€ ê¸°ì¤€ (í•„ìš”ì‹œ ì¡°ì •)
      }
      function groupMarkersByProximity(locs, map, pixelThreshold) {
        const groups = [];
        const visited = new Array(locs.length).fill(false);
        for (let i = 0; i < locs.length; i++) {
          if (visited[i]) continue;
          visited[i] = true;
          const base = locs[i];
          const basePoint = map.latLngToLayerPoint([base.lat, base.lng]);
          const group = [base];
          for (let j = i + 1; j < locs.length; j++) {
            if (visited[j]) continue;
            const comp = locs[j];
            const compPoint = map.latLngToLayerPoint([comp.lat, comp.lng]);
            if (basePoint.distanceTo(compPoint) <= pixelThreshold) {
              visited[j] = true;
              group.push(comp);
            }
          }
          groups.push(group);
        }
        return groups;
      }

      // ë°ì´í„° í…Œì´ë¸” ë Œë”ë§
      function renderTable(data) {
        tbody.innerHTML = '';
        data.forEach(row => {
          const tr = document.createElement('tr');
          // ìœ„ë„ì™€ ê²½ë„ ë°ì´í„°ë¥¼ ìˆ¨ê²¨ì§„ td ìš”ì†Œë¡œ ì¶”ê°€
          tr.innerHTML = `<td>${row.name}</td><td>${row.address || ''}</td><td style="display:none;">${row.lat}</td><td style="display:none;">${row.lng}</td>`;
          tr.addEventListener('click', () => addSelected(row));
          tbody.appendChild(tr);
        });
      }
      // ì„ íƒëœ ë¦¬ìŠ¤íŠ¸ ë Œë”ë§
      function renderSelected() {
        selectedTbody.innerHTML = '';
        selectedData.forEach((row, idx) => {
          const tr = document.createElement('tr');
          // ìœ„ë„ì™€ ê²½ë„ ë°ì´í„°ë¥¼ ìˆ¨ê²¨ì§„ td ìš”ì†Œë¡œ ì¶”ê°€ (ì´ ë¶€ë¶„ì„ ìˆ˜ì •í•©ë‹ˆë‹¤)
          tr.innerHTML = `<td>${row.name}</td><td>${row.address || ''}</td><td style="display:none;">${row.lat.toFixed(6)}</td><td style="display:none;">${row.lng.toFixed(6)}</td>`;
          tr.addEventListener('click', () => removeSelected(idx));
          selectedTbody.appendChild(tr);
        });
        refreshMap();
        updateOffscreenIndicators(); // âœ¨ ì„ íƒ ë¦¬ìŠ¤íŠ¸ ë³€ê²½ ì‹œ ì§€í‘œë„ ì—…ë°ì´íŠ¸
      }

      // ì¢Œí‘œ í¬í•¨ ì—‘ì…€ ì—…ë¡œë“œ
      inputExcel.addEventListener('change', e => {
        const file = e.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = evt => {
          const data = new Uint8Array(evt.target.result);
          const workbook = XLSX.read(data, { type: 'array' });
          const firstSheetName = workbook.SheetNames[0];
          const worksheet = workbook.Sheets[firstSheetName];
          const jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1 });
          fullData = jsonData.slice(1).map(row => ({
            name: row[0] || '',
            address: row[1] || '',
            lat: row[2] !== undefined ? parseFloat(row[2]) || 0 : 0,
            lng: row[3] !== undefined ? parseFloat(row[3]) || 0 : 0
          }));
          renderTable(fullData);
          saveFullDataToLocalStorage(); // âœ¨ ë¡œì»¬ ìŠ¤í† ë¦¬ì§€ì— ì €ì¥
        };
        reader.readAsArrayBuffer(file);
      });

      // ê²€ìƒ‰ ê¸°ëŠ¥ (âœ¨ ì´ˆì„±ìœ¼ë¡œë§Œ ë˜ì–´ìˆìœ¼ë©´ ì´ˆì„±ê²€ìƒ‰, ê·¸ ì™¸ëŠ” ë‹¨ì–´ê²€ìƒ‰)
      searchInput.addEventListener('input', function() {
          const keyword = this.value.trim().toLowerCase(); // ì‚¬ìš©ì ê²€ìƒ‰ì–´

          if (!keyword) {
              renderTable(fullData); // ê²€ìƒ‰ì–´ê°€ ì—†ìœ¼ë©´ ì „ì²´ ë°ì´í„° í‘œì‹œ
              saveFullDataToLocalStorage();
              return;
          }

          // âœ¨ ê²€ìƒ‰ì–´ì˜ ì¢…ë¥˜ë¥¼ íŒë‹¨
          const isOnlyInitials = isOnlyKoreanInitials(keyword);

          const filtered = fullData.filter(row => {
              const name = row.name ? row.name.toLowerCase() : ''; // ì—…ì²´ëª… (name)

              if (isOnlyInitials) {
                  // ê²€ìƒ‰ì–´ê°€ ì´ˆì„±ìœ¼ë¡œë§Œ êµ¬ì„±ë˜ì–´ ìˆìœ¼ë©´ ì´ˆì„± ê²€ìƒ‰ ìˆ˜í–‰
                  const nameInitials = getKoreanInitialConsonants(name); // ì—…ì²´ëª…ì˜ ì´ˆì„±
                  const keywordInitials = getKoreanInitialConsonants(keyword); // ì‚¬ìš©ì ê²€ìƒ‰ì–´ì˜ ì´ˆì„±
                  return nameInitials.includes(keywordInitials); // ì—…ì²´ëª…ì˜ ì´ˆì„±ì— ê²€ìƒ‰ì–´ ì´ˆì„± í¬í•¨
              } else {
                  // ê²€ìƒ‰ì–´ê°€ ì´ˆì„±ì´ ì•„ë‹Œ ì¼ë°˜ ë‹¨ì–´ì´ê±°ë‚˜ ë‹¤ë¥¸ ë¬¸ìê°€ í¬í•¨ë˜ì–´ ìˆìœ¼ë©´ ë‹¨ì–´ ê²€ìƒ‰ ìˆ˜í–‰
                  return name.includes(keyword); // ì—…ì²´ëª…ì— ì›ë³¸ ê²€ìƒ‰ì–´ í¬í•¨
              }
          });

          renderTable(filtered); // í•„í„°ë§ëœ ë°ì´í„°ë¡œ í…Œì´ë¸” ê°±ì‹ 
          saveFullDataToLocalStorage();
      });

      // âœ¨ ë°°ì—´ì„ ë¬´ì‘ìœ„ë¡œ ì„ëŠ” Fisher-Yates (Knuth) ì…”í”Œ ì•Œê³ ë¦¬ì¦˜
      function shuffleArray(array) {
          for (let i = array.length - 1; i > 0; i--) {
              const j = Math.floor(Math.random() * (i + 1));
              [array[i], array[j]] = [array[j], array[i]]; // ìš”ì†Œ êµí™˜
          }
      }

      // ì§€ë„ ê°±ì‹ 
      async function refreshMap() {
          markersGroup.clearLayers();
          myCompanyMarker.addTo(map);

          if (window.labelLinesGroup) {
            window.labelLinesGroup.clearLayers();
          } else {
            window.labelLinesGroup = L.layerGroup().addTo(map);
          }

          if (polylineLayer) {
              map.removeLayer(polylineLayer);
              polylineLayer = null;
          }

          const zoom = map.getZoom();
          const threshold = getPixelThreshold(zoom);
          const grouped = groupMarkersByProximity(selectedData, map, threshold);

          const baseOffset = 15; // ë§ˆì»¤ì—ì„œ ë¼ë²¨ì˜ ì´ˆê¸° ì˜¤í”„ì…‹ (í”½ì…€)
          const labelMoveStep = 20; // 8ë°©í–¥ íƒìƒ‰ ì‹œ ë¼ë²¨ì„ ì´ë™ì‹œí‚¬ í”½ì…€ ê°„ê²©
          const maxOverlapIterations = 100; // ê²¹ì¹¨ í•´ê²° ì‹œë„ ìµœëŒ€ ë°˜ë³µ íšŸìˆ˜

          const markersWithPos = []; // ë¼ë²¨ ë§ˆì»¤, í˜„ì¬ í™”ë©´ ìƒ ìœ„ì¹˜, í¬ê¸°, ì›ë³¸ LatLng ì •ë³´ë¥¼ ì €ì¥
          const realMarkerPixelBounds = []; // ëª¨ë“  ì‹¤ì œ ë§ˆì»¤ì˜ í”½ì…€ ê²½ê³„ (í”¼í•´ì•¼ í•  ì˜ì—­)ë¥¼ ì €ì¥í•  ë°°ì—´

          for (const group of grouped) {
              const popupContent = group.map(item => `
                <div class="nav-link"
                    data-name="${item.name}"
                    data-address="${item.address || ''}"
                    style="cursor:pointer; color:#007bff; font-weight:bold;">
                  ${item.name}<br/>
                  <span>${item.address || 'ì£¼ì†Œ ì—†ìŒ'}</span>
                </div>
              `).join('<hr>');

              const base = group[0];
              const baseLatLng = L.latLng(base.lat, base.lng);

              const realMarker = L.marker(baseLatLng).addTo(markersGroup);
              realMarker.bindPopup(popupContent);

              realMarker.on('popupopen', (e) => {
                const popupEl = e.popup.getElement();
                popupEl.querySelectorAll('.nav-link').forEach(el => {
                  el.addEventListener('click', () => {
                    const name = el.getAttribute('data-name');
                    const address = el.getAttribute('data-address');
                    openNavModal(name, address);
                  });
                });
              });

              // ì‹¤ì œ ë§ˆì»¤ì˜ í”½ì…€ ê²½ê³„ ê³„ì‚° ë° ì €ì¥
              const defaultMarkerIconSize = L.point(25, 41);
              const defaultMarkerIconAnchor = L.point(12, 41);
              const realMarkerPixelPos = map.latLngToLayerPoint(baseLatLng);
              const realMarkerTopLeft = realMarkerPixelPos.subtract(defaultMarkerIconAnchor);
              realMarkerPixelBounds.push(L.bounds(realMarkerTopLeft, realMarkerTopLeft.add(defaultMarkerIconSize)));


              const html = group.map(i => i.name).join('<br />');
              const labelIconAnchor = L.point(0, 20); // ì»¤ìŠ¤í…€ DivIconì˜ ì•µì»¤ í¬ì¸íŠ¸
              const icon = L.divIcon({
                className: 'name-list-label',
                html,
                iconSize: null,
                iconAnchor: labelIconAnchor // ì •ì˜ëœ ì•µì»¤ ì‚¬ìš©
              });

              let pos = map.latLngToLayerPoint(baseLatLng).add([baseOffset, 0]);
              const labelMarker = L.marker(map.layerPointToLatLng(pos), {
                icon,
                interactive: true,
                pane: 'labelPane'
              }).addTo(markersGroup);

              labelMarker.bindPopup(popupContent);

              labelMarker.on('popupopen', (e) => {
                const popupEl = e.popup.getElement();
                popupEl.querySelectorAll('.nav-link').forEach(el => {
                  el.addEventListener('click', () => {
                    const name = el.getAttribute('data-name');
                    const address = el.getAttribute('data-address');
                    openNavModal(name, address);
                  });
                });
              });

              await new Promise(resolve => {
                  const checkElement = () => {
                      const el = labelMarker.getElement();
                      if (el) {
                          markersWithPos.push({
                              marker: labelMarker,
                              initialPos: pos.clone(),
                              pos,
                              width: el.offsetWidth,
                              height: el.offsetHeight,
                              originalLatLng: baseLatLng,
                              labelIconAnchor: labelIconAnchor
                          });
                          resolve();
                      } else {
                          setTimeout(checkElement, 10);
                      }
                  };
                  checkElement();
              });
          }

          const directions = [
              L.point(1, 0),    // ì˜¤ë¥¸ìª½
              L.point(1, -1),   // ì˜¤ë¥¸ìª½ ìœ„
              L.point(0, -1),   // ìœ„
              L.point(-1, -1),  // ì™¼ìª½ ìœ„
              L.point(-1, 0),   // ì™¼ìª½
              L.point(-1, 1),   // ì™¼ìª½ ì•„ë˜
              L.point(0, 1),    // ì•„ë˜
              L.point(1, 1)     // ì˜¤ë¥¸ìª½ ì•„ë˜
          ];

          let overlapped = true;
          let iteration = 0;

          while (overlapped && iteration < maxOverlapIterations) {
              overlapped = false;
              // âœ¨ ë§¤ ë°˜ë³µë§ˆë‹¤ ë¼ë²¨ ì²˜ë¦¬ ìˆœì„œë¥¼ ë¬´ì‘ìœ„ë¡œ ì„ìŒ
              shuffleArray(markersWithPos);

              for (let i = 0; i < markersWithPos.length; i++) {
                  const currentLabel = markersWithPos[i];

                  const currentLabelTopLeft = currentLabel.pos.subtract(currentLabel.labelIconAnchor);
                  const currentBounds = L.bounds(currentLabelTopLeft, currentLabelTopLeft.add([currentLabel.width, currentLabel.height]));

                  let hasOverlap = false;

                  // ë‹¤ë¥¸ ë¼ë²¨ë“¤ê³¼ì˜ ê²¹ì¹¨ í™•ì¸
                  for (let j = 0; j < markersWithPos.length; j++) {
                      if (i === j) continue;

                      const otherLabel = markersWithPos[j];
                      const otherLabelTopLeft = otherLabel.pos.subtract(otherLabel.labelIconAnchor);
                      const otherBounds = L.bounds(otherLabelTopLeft, otherLabelTopLeft.add([otherLabel.width, otherLabel.height]));

                      if (currentBounds.intersects(otherBounds)) {
                          hasOverlap = true;
                          overlapped = true;
                          break;
                      }
                  }

                  // ì‹¤ì œ ë§ˆì»¤(obstacle)ì™€ì˜ ê²¹ì¹¨ í™•ì¸
                  if (!hasOverlap) {
                      for (let k = 0; k < realMarkerPixelBounds.length; k++) {
                          const realMarkerBounds = realMarkerPixelBounds[k];
                          if (currentBounds.intersects(realMarkerBounds)) {
                              hasOverlap = true;
                              overlapped = true;
                              break;
                          }
                      }
                  }

                  if (hasOverlap) {
                      let foundSpot = false;
                      const basePixelPos = map.latLngToLayerPoint(currentLabel.originalLatLng);

                      for (const dir of directions) {
                          const proposedPos = basePixelPos.add(dir.multiplyBy(baseOffset + labelMoveStep * iteration));

                          const proposedLabelTopLeft = proposedPos.subtract(currentLabel.labelIconAnchor);
                          const proposedBounds = L.bounds(proposedLabelTopLeft, proposedLabelTopLeft.add([currentLabel.width, currentLabel.height]));

                          let conflict = false;

                          // ì œì•ˆëœ ìœ„ì¹˜ê°€ ë‹¤ë¥¸ ë¼ë²¨ê³¼ ê²¹ì¹˜ëŠ”ì§€ í™•ì¸
                          for (let k = 0; k < markersWithPos.length; k++) {
                              if (i === k) continue;
                              const existingLabel = markersWithPos[k];
                              const existingLabelTopLeft = existingLabel.pos.subtract(existingLabel.labelIconAnchor);
                              const existingBounds = L.bounds(existingLabelTopLeft, existingLabelTopLeft.add([existingLabel.width, existingLabel.height]));

                              if (proposedBounds.intersects(existingBounds)) {
                                  conflict = true;
                                  break;
                              }
                          }

                          // ì œì•ˆëœ ìœ„ì¹˜ê°€ ì‹¤ì œ ë§ˆì»¤(obstacle)ì™€ ê²¹ì¹˜ëŠ”ì§€ í™•ì¸
                          if (!conflict) {
                              for (let k = 0; k < realMarkerPixelBounds.length; k++) {
                                  const realMarkerBounds = realMarkerPixelBounds[k];
                                  if (proposedBounds.intersects(realMarkerBounds)) {
                                      conflict = true;
                                      break;
                                  }
                              }
                          }

                          if (!conflict) {
                              currentLabel.pos = proposedPos;
                              foundSpot = true;
                              break;
                          }
                      }
                  }
              }
              iteration++;
              await new Promise(r => setTimeout(r, 0));
          }

          window.labelLinesGroup.clearLayers();

          markersWithPos.forEach(({ marker, pos, originalLatLng, width, height, labelIconAnchor }) => {
              const labelTopLeftPixel = pos.subtract(labelIconAnchor);
              const labelCenterPixel = labelTopLeftPixel.add([width / 2, height / 2]);
              const labelCenterLatLng = map.layerPointToLatLng(labelCenterPixel);

              const line = L.polyline([originalLatLng, labelCenterLatLng], {
                  color: 'blue',
                  weight: 3,
                  pane: 'overlayPane'
              });
              window.labelLinesGroup.addLayer(line);

              const labelLatLng = map.layerPointToLatLng(pos);
              marker.setLatLng(labelLatLng);
          });
      }

      // âœ¨ í™”ë©´ ë°– ë§ˆì»¤ ì§€í‘œ ê´€ë ¨ ë³€ìˆ˜ ë° í•¨ìˆ˜
      let offscreenIndicators = {}; // Key: marker's unique ID, Value: indicator element
      const offscreenIndicatorsContainer = document.getElementById('offscreen-indicators-container'); // ì»¨í…Œì´ë„ˆ ìš”ì†Œ ê°€ì ¸ì˜¤ê¸°
      const toggleOffscreenMarkersBtn = document.getElementById('toggle-offscreen-markers'); // í† ê¸€ ë²„íŠ¼ ê°€ì ¸ì˜¤ê¸°

      function updateOffscreenIndicators() {
          // offscreen-indicators-containerê°€ ìˆ¨ê²¨ì ¸ ìˆìœ¼ë©´ ì—…ë°ì´íŠ¸ ë¡œì§ ì‹¤í–‰í•˜ì§€ ì•ŠìŒ
          if (offscreenIndicatorsContainer.style.display === 'none') {
              // í˜„ì¬ ë³´ì´ëŠ” ëª¨ë“  ì§€í‘œë¥¼ ì œê±°í•˜ì—¬ ê¹¨ë—í•˜ê²Œ ìœ ì§€
              Object.values(offscreenIndicators).forEach(indicator => indicator.remove());
              offscreenIndicators = {};
              return;
          }

          const mapBounds = map.getBounds();
          const mapContainer = map.getContainer(); // ì§€ë„ì˜ HTML ì»¨í…Œì´ë„ˆ ìš”ì†Œ
          const mapRect = mapContainer.getBoundingClientRect(); // ì§€ë„ì˜ í˜„ì¬ í¬ê¸° ë° ìœ„ì¹˜
          const mapWidth = mapRect.width;
          const mapHeight = mapRect.height;

          // ì§€ë„ì˜ ì¤‘ì‹¬ì ì˜ í”½ì…€ ì¢Œí‘œ
          const centerPoint = map.latLngToContainerPoint(map.getCenter());

          if (!offscreenIndicatorsContainer) {
              console.error("Offscreen indicators container not found.");
              return;
          }

          // í˜„ì¬ í™”ë©´ì— ë³´ì´ëŠ” ë§ˆì»¤ë“¤ì˜ IDë¥¼ ì¶”ì í•˜ì—¬ í•„ìš” ì—†ëŠ” ì§€í‘œ ì œê±°ì— ì‚¬ìš©
          const visibleMarkerIds = new Set();

          selectedData.forEach(marker => {
              const markerLatLng = L.latLng(marker.lat, marker.lng);
              // ë§ˆì»¤ì˜ ê³ ìœ  ID (ì´ë¦„, ìœ„ë„, ê²½ë„ ì¡°í•©)
              const markerId = marker.name + '_' + marker.lat + '_' + marker.lng;

              // ë§ˆì»¤ê°€ í˜„ì¬ ì§€ë„ í™”ë©´ ë°–ì— ìˆëŠ”ì§€ í™•ì¸
              if (!mapBounds.contains(markerLatLng)) {
                  visibleMarkerIds.add(markerId); // ì§€í‘œê°€ í•„ìš”í•œ ë§ˆì»¤ë¡œ í‘œì‹œ

                  let indicator = offscreenIndicators[markerId];

                  if (!indicator) {
                      // ì§€í‘œê°€ ì—†ìœ¼ë©´ ìƒˆë¡œ ìƒì„±
                      indicator = document.createElement('div');
                      indicator.className = 'offscreen-indicator';
                      indicator.title = marker.name; // ë§ˆìš°ìŠ¤ ì˜¤ë²„ ì‹œ ë§ˆì»¤ ì´ë¦„ í‘œì‹œ
                      offscreenIndicatorsContainer.appendChild(indicator);
                      offscreenIndicators[markerId] = indicator;

                      // âœ¨ í´ë¦­ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì¶”ê°€: ë‚´ë¹„ê²Œì´ì…˜ ëª¨ë‹¬ ì—´ê¸°
                      indicator.addEventListener('click', () => {
                          openNavModal(marker.name, marker.address);
                      });
                  }

                  // ë§ˆì»¤ì˜ í”½ì…€ ì¢Œí‘œ (ì§€ë„ ì»¨í…Œì´ë„ˆ ê¸°ì¤€)
                  const markerContainerPoint = map.latLngToContainerPoint(markerLatLng);

                  // ì§€ë„ ì¤‘ì‹¬ì—ì„œ ë§ˆì»¤ê¹Œì§€ì˜ ë²¡í„°
                  const dx = markerContainerPoint.x - centerPoint.x;
                  const dy = markerContainerPoint.y - centerPoint.y;

                  // ë²¡í„°ì˜ ê°ë„ (ë¼ë””ì•ˆ) ê³„ì‚°
                  const angle = Math.atan2(dy, dx);

                  // CSS rotation (â–¶ points right by default)
                  const rotationDegrees = angle * (180 / Math.PI);

                  let intersectionX, intersectionY;
                  let minT = Infinity;

                  // Helper function to calculate t and validate it for a given boundary
                  const calculateT = (numerator, denominator) => {
                      // 0ìœ¼ë¡œ ë‚˜ëˆ„ëŠ” ê²½ìš° ë°©ì§€ (í‰í–‰í•œ ê²½ìš°)
                      if (denominator === 0) return Infinity;
                      const t_val = numerator / denominator;
                      // ì¤‘ì‹¬ì—ì„œ ë©€ì–´ì§€ëŠ” ë°©í–¥ì˜ t ê°’ë§Œ ìœ íš¨ (ìŒìˆ˜ëŠ” ë’¤ìª½)
                      if (t_val >= 0) return t_val;
                      return Infinity;
                  };

                  // ìˆ˜ì§ ê²½ê³„ (ì™¼ìª½/ì˜¤ë¥¸ìª½)ì™€ êµì°¨ì  í™•ì¸
                  let t_x_left = calculateT(0 - centerPoint.x, dx);
                  let t_x_right = calculateT(mapWidth - centerPoint.x, dx);

                  if (t_x_left !== Infinity) {
                      const y_at_left = centerPoint.y + t_x_left * dy;
                      // í•´ë‹¹ êµì°¨ì ì˜ y ì¢Œí‘œê°€ ìœ íš¨í•œ ë²”ìœ„ ë‚´ì— ìˆëŠ”ì§€ í™•ì¸
                      if (y_at_left >= 0 && y_at_left <= mapHeight) {
                          minT = Math.min(minT, t_x_left);
                      }
                  }
                  if (t_x_right !== Infinity) {
                      const y_at_right = centerPoint.y + t_x_right * dy;
                      // í•´ë‹¹ êµì°¨ì ì˜ y ì¢Œí‘œê°€ ìœ íš¨í•œ ë²”ìœ„ ë‚´ì— ìˆëŠ”ì§€ í™•ì¸
                      if (y_at_right >= 0 && y_at_right <= mapHeight) {
                          minT = Math.min(minT, t_x_right);
                      }
                  }

                  // ìˆ˜í‰ ê²½ê³„ (ìƒë‹¨/í•˜ë‹¨)ì™€ êµì°¨ì  í™•ì¸
                  let t_y_top = calculateT(0 - centerPoint.y, dy);
                  let t_y_bottom = calculateT(mapHeight - centerPoint.y, dy);

                  if (t_y_top !== Infinity) {
                      const x_at_top = centerPoint.x + t_y_top * dx;
                      // í•´ë‹¹ êµì°¨ì ì˜ x ì¢Œí‘œê°€ ìœ íš¨í•œ ë²”ìœ„ ë‚´ì— ìˆëŠ”ì§€ í™•ì¸
                      if (x_at_top >= 0 && x_at_top <= mapWidth) {
                          minT = Math.min(minT, t_y_top);
                      }
                  }
                  if (t_y_bottom !== Infinity) {
                      const x_at_bottom = centerPoint.x + t_y_bottom * dx;
                      // í•´ë‹¹ êµì°¨ì ì˜ x ì¢Œí‘œê°€ ìœ íš¨í•œ ë²”ìœ„ ë‚´ì— ìˆëŠ”ì§€ í™•ì¸
                      if (x_at_bottom >= 0 && x_at_bottom <= mapWidth) {
                          minT = Math.min(minT, t_y_bottom);
                      }
                  }

                  // ìµœì¢… êµì°¨ì  ê³„ì‚°
                  if (minT === Infinity) {
                      // ëª¨ë“  ê²½ê³„ì™€ êµì°¨í•˜ì§€ ì•ŠëŠ” ë“œë¬¸ ê²½ìš° (ì˜ˆ: ë§ˆì»¤ê°€ ì§€ë„ ì¤‘ì‹¬ì— ìˆê±°ë‚˜, ì„ ì´ ê²½ê³„ë¥¼ ë²—ì–´ë‚˜ì§€ ì•ŠëŠ” ê²½ìš°)
                      // ì´ ê²½ìš°, ì„ì‹œë¡œ ì´ì „ì˜ ê³ ì • ê±°ë¦¬ í´ë¨í•‘ ë°©ì‹ì„ ì‚¬ìš© (í™”ë©´ ì¤‘ê°„ì¯¤ì— ìœ„ì¹˜)
                      const indicatorSize = 60;
                      const halfSize = indicatorSize / 2;
                      const fallbackDistance = Math.max(mapWidth, mapHeight) * 0.45; // í™”ë©´ ì¤‘ê°„ì— ê°€ê¹ê²Œ

                      intersectionX = centerPoint.x + fallbackDistance * Math.cos(angle);
                      intersectionY = centerPoint.y + fallbackDistance * Math.sin(angle);

                      // ìµœì¢…ì ìœ¼ë¡œ í™”ë©´ ë²”ìœ„ ë‚´ë¡œ í´ë¨í•‘ (ì§€í‘œê°€ ì˜ë¦¬ì§€ ì•Šë„ë¡)
                      intersectionX = Math.max(halfSize, Math.min(intersectionX, mapWidth - halfSize));
                      intersectionY = Math.max(halfSize, Math.min(intersectionY, mapHeight - halfSize));

                  } else {
                      // ê°€ì¥ ê°€ê¹Œìš´ ê²½ê³„ êµì°¨ì ì„ ì§€í‘œì˜ ì¤‘ì•™ ìœ„ì¹˜ë¡œ ì„¤ì •
                      intersectionX = centerPoint.x + minT * dx;
                      intersectionY = centerPoint.y + minT * dy;

                      // ì§€í‘œê°€ í™”ë©´ ë°–ìœ¼ë¡œ ì˜ë¦¬ì§€ ì•Šë„ë¡ ìµœì¢…ì ìœ¼ë¡œ í´ë¨í•‘ (ì§€í‘œ í¬ê¸° ê³ ë ¤)
                      const indicatorSize = 60; // CSSì— ì •ì˜ëœ ì§€í‘œ í¬ê¸°
                      const halfSize = indicatorSize / 2;
                      intersectionX = Math.max(halfSize, Math.min(intersectionX, mapWidth - halfSize));
                      intersectionY = Math.max(halfSize, Math.min(intersectionY, mapHeight - halfSize));
                  }

                  // ì§€í‘œ ìŠ¤íƒ€ì¼ ì ìš© ë° ë‚´ìš© ì„¤ì •
                  indicator.style.left = `${intersectionX}px`;
                  indicator.style.top = `${intersectionY}px`;
                  indicator.style.transform = `translate(-50%, -50%)`; // ì»¨í…Œì´ë„ˆëŠ” ì¤‘ì•™ ì •ë ¬ë§Œ ë‹´ë‹¹

                  // í™”ì‚´í‘œì™€ ë§ˆì»¤ ì´ë¦„ í•¨ê»˜ í‘œì‹œ
                  // âœ¨ í™”ì‚´í‘œ ì•„ì´ì½˜ì„ ê¼¬ë¦¬ ë‹¬ë¦° í™”ì‚´í‘œë¡œ ë³€ê²½ (â”)
                  indicator.innerHTML = `<div class="arrow-icon">â”</div><div class="marker-name-text">${marker.name}</div>`;

                  // âœ¨ í™”ì‚´í‘œ ì•„ì´ì½˜ë§Œ íšŒì „
                  const arrowIcon = indicator.querySelector('.arrow-icon');
                  if (arrowIcon) {
                      arrowIcon.style.transform = `rotate(${rotationDegrees}deg)`;
                  }
                  indicator.style.display = 'flex'; // ì§€í‘œë¥¼ ë³´ì´ë„ë¡ ì„¤ì •
              } else {
                  // ë§ˆì»¤ê°€ í™”ë©´ ì•ˆì— ìˆìœ¼ë©´ í•´ë‹¹ ì§€í‘œë¥¼ ìˆ¨ê¹€
                  const indicator = offscreenIndicators[markerId];
                  if (indicator) {
                      indicator.style.display = 'none';
                  }
              }
          });

          // ì´ì œ ë” ì´ìƒ í™”ë©´ ë°–ì— ìˆì§€ ì•Šê±°ë‚˜ (í™”ë©´ ì•ˆìœ¼ë¡œ ë“¤ì–´ì™”ê±°ë‚˜)
          // selectedDataì—ì„œ ì‚­ì œëœ ë§ˆì»¤ì˜ ì§€í‘œë¥¼ ì œê±°
          Object.keys(offscreenIndicators).forEach(markerId => {
              if (!visibleMarkerIds.has(markerId)) {
                  if (offscreenIndicators[markerId]) {
                      offscreenIndicatorsContainer.removeChild(offscreenIndicators[markerId]);
                  }
                  delete offscreenIndicators[markerId];
              }
          });
      }

      // âœ¨ í™”ë©´ ë°– ë§ˆì»¤ í‘œì‹œ/ìˆ¨ê¸°ê¸° í† ê¸€ ê¸°ëŠ¥
      toggleOffscreenMarkersBtn.addEventListener('click', () => {
          const isHidden = offscreenIndicatorsContainer.style.display === 'none';
          if (isHidden) {
              offscreenIndicatorsContainer.style.display = 'block';
              toggleOffscreenMarkersBtn.textContent = 'í™”ë©´ ë°– ë§ˆì»¤ ìˆ¨ê¸°ê¸°';
              localStorage.setItem('offscreenMarkersVisible', 'true');
          } else {
              offscreenIndicatorsContainer.style.display = 'none';
              toggleOffscreenMarkersBtn.textContent = 'í™”ë©´ ë°– ë§ˆì»¤ í‘œì‹œ';
              localStorage.setItem('offscreenMarkersVisible', 'false');
          }
          updateOffscreenIndicators(); // ìƒíƒœ ë³€ê²½ í›„ ì§€í‘œ ì—…ë°ì´íŠ¸ ê°•ì œ ì‹¤í–‰
      });

      // ì„ íƒ ë¦¬ìŠ¤íŠ¸ ì—‘ì…€ ë‹¤ìš´ë¡œë“œ
      downloadBtn.addEventListener('click', () => {
        if (selectedData.length === 0) {
          alert("ì„ íƒëœ ë¦¬ìŠ¤íŠ¸ê°€ ì—†ìŠµë‹ˆë‹¤.");
          return;
        }
        const worksheetData = [
          ["ì—…ì²´ëª…", "ì£¼ì†Œ", "ìœ„ë„", "ê²½ë„"],
          ...selectedData.map(item => [item.name, item.address, item.lat, item.lng])
        ];
        const worksheet = XLSX.utils.aoa_to_sheet(worksheetData);
        const workbook = XLSX.utils.book_new();
        XLSX.utils.book_append_sheet(workbook, worksheet, "SelectedList");
        XLSX.writeFile(workbook, "selected_list.xlsx");
      });

      // Google Geocoding APIë¥¼ ì´ìš©í•œ ì£¼ì†Œ â†’ ìœ„ë„ê²½ë„ ë³€í™˜ í•¨ìˆ˜
      async function getCoordsByAddress(address) {
        const apiKey = "AIzaSyBxaNCAfmnLjdC_qxdG3lhuRVHOh0Vii8w"; // êµ¬ê¸€ API í‚¤
        const url = `https://maps.googleapis.com/maps/api/geocode/json?address=${encodeURIComponent(address)}&key=${apiKey}`;

        try {
          console.log("ì£¼ì†Œ ë³€í™˜ ìš”ì²­:", address);
          const res = await fetch(url);
          console.log("ì‘ë‹µ ìƒíƒœ:", res.status);
          if (!res.ok) {
            console.error("API ìš”ì²­ ì‹¤íŒ¨", res.status);
            return null;
          }
          const data = await res.json();
          console.log("ì‘ë‹µ ë°ì´í„°:", data);

          if (data.status === "OK" && data.results.length > 0) {
            const location = data.results[0].geometry.location;
            return {
              lat: location.lat,
              lng: location.lng
            };
          } else {
            console.warn("ì£¼ì†Œ ê²€ìƒ‰ ê²°ê³¼ ì—†ìŒ ë˜ëŠ” ì˜¤ë¥˜ ìƒíƒœ:", data.status);
            return null;
          }
        } catch (e) {
          console.error("ì£¼ì†Œ ë³€í™˜ ì—ëŸ¬", e);
          return null;
        }
      }

      // ì£¼ì†Œë§Œ í¬í•¨ ì—‘ì…€ ì—…ë¡œë“œ
      inputExcelAddr.addEventListener('change', e => {
        const file = e.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = evt => {
          const data = new Uint8Array(evt.target.result);
          const workbook = XLSX.read(data, { type: 'array' });
          const firstSheetName = workbook.SheetNames[0];
          const worksheet = workbook.Sheets[firstSheetName];
          const jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1 });
          addrOnlyData = jsonData.slice(1).map(row => ({
            name: row[0] || '',
            address: row[1] || '',
            lat: 0,
            lng: 0
          }));
          alert(`ì£¼ì†Œ ë°ì´í„° ${addrOnlyData.length}ê±´ ì¤€ë¹„ ì™„ë£Œ`);
        };
        reader.readAsArrayBuffer(file);
      });

      // ë³€í™˜ ë²„íŠ¼ í´ë¦­ ì‹œ ë¹„ë°€ë²ˆí˜¸ ëª¨ë‹¬ ë„ìš°ê¸°
      convertBtn.addEventListener('click', () => {
        if (addrOnlyData.length === 0) {
          alert("ì£¼ì†Œ ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.");
          return;
        }
        passwordInput.value = '';
        passwordError.style.display = 'none';
        passwordModal.classList.add('flex');
        passwordInput.focus();
      });

      // ë¹„ë°€ë²ˆí˜¸ í™•ì¸ ë²„íŠ¼
      passwordSubmit.addEventListener('click', async () => {
        const entered = passwordInput.value;
        if (entered === correctPassword) {
          passwordModal.classList.remove('flex');
          await convertAddressesToCoords();
        } else {
          passwordError.style.display = 'block';
          passwordInput.focus();
        }
      });

      // ë¹„ë°€ë²ˆí˜¸ ì·¨ì†Œ ë²„íŠ¼
      passwordCancel.addEventListener('click', () => {
        passwordModal.classList.remove('flex');
      });

      // ì—”í„°í‚¤ ëˆŒë €ì„ ë•Œ í™•ì¸ ì²˜ë¦¬
      passwordInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
          passwordSubmit.click();
        }
      });

      // ì£¼ì†Œ ë³€í™˜ + ë‹¤ìš´ë¡œë“œ í•¨ìˆ˜
      async function convertAddressesToCoords() {
      loadingIndicator.style.display = 'block';

      for(let i = 0; i < addrOnlyData.length; i++) {
          const item = addrOnlyData[i];
          if (!item.address || item.address.trim() === '') {
          item.lat = 0;
          item.lng = 0;
          continue;
          }
          const coords = await getCoordsByAddress(item.address);
          if(coords) {
          item.lat = coords.lat;
          item.lng = coords.lng;
          } else {
          item.lat = 0;
          item.lng = 0;
          }
          await new Promise(r => setTimeout(r, 300)); // API ìš”ì²­ ì†ë„ ì¡°ì ˆ
      }

      // lat,lngê°€ 0ì¸ í•­ëª© ì œê±°
      const filteredData = addrOnlyData.filter(item => !(item.lat === 0 && item.lng === 0));

      const worksheetData = [
          ["ì—…ì²´ëª…", "ì£¼ì†Œ", "ìœ„ë„", "ê²½ë„"],
          ...filteredData.map(item => [item.name, item.address, item.lat, item.lng])
      ];
      const worksheet = XLSX.utils.aoa_to_sheet(worksheetData);
      const workbook = XLSX.utils.book_new();
      XLSX.utils.book_append_sheet(workbook, worksheet, "ConvertedCoords");
      XLSX.writeFile(workbook, "converted_coordinates.xlsx");

      loadingIndicator.style.display = 'none';
      }
      // ì§€ë„ í™•ëŒ€ ì¶•ì†Œ ì‹œ ë§ˆì»¤ ë° ë¼ë²¨ ì¬ë°°ì¹˜
      map.on('zoomend', () => {
        refreshMap();
        updateOffscreenIndicators(); // âœ¨ ì¤Œ ë³€ê²½ ì‹œ ì§€í‘œë„ ì—…ë°ì´íŠ¸
      });

      // âœ¨ ì§€ë„ ì´ë™ ì‹œ ì§€í‘œ ì—…ë°ì´íŠ¸
      map.on('moveend', updateOffscreenIndicators);


      // ë‚´ìœ„ì¹˜í‘œì‹œì‹œ
      const locateBtn = document.getElementById('locate-btn');
      let userLocationMarker = null;

      locateBtn.addEventListener('click', () => {
      if (!navigator.geolocation) {
          alert("í˜„ì¬ ë¸Œë¼ìš°ì €ì—ì„œ ìœ„ì¹˜ ì •ë³´ë¥¼ ì§€ì›í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.");
          return;
      }

      locateBtn.disabled = true;
      locateBtn.textContent = "ìœ„ì¹˜ íƒìƒ‰ ì¤‘...";

      navigator.geolocation.getCurrentPosition(
          position => {
          const lat = position.coords.latitude;
          const lng = position.coords.longitude;

          if (userLocationMarker) {
              userLocationMarker.setLatLng([lat, lng]);
          } else {
              userLocationMarker = L.marker([lat, lng], {
              title: "ë‚´ ìœ„ì¹˜",
              icon: L.divIcon({
                  className: '',
                  html: `<div style="
                  width: 24px;
                  height: 24px;
                  background: blue;
                  border: 3px solid white;
                  border-radius: 50%;
                  box-shadow: 0 0 8px 2px rgba(0,0,255,0.7);
                  "></div>`,
                  iconSize: [60, 60], /* ë³€ê²½: [30, 30] -> [60, 60] */
                  iconAnchor: [30, 30], /* ë³€ê²½: [15, 15] -> [30, 30] */
                  popupAnchor: [0, -30] /* ë³€ê²½: [0, -15] -> [0, -30] */
              })
              }).addTo(map).bindPopup("ë‚´ ìœ„ì¹˜");
          }

          map.setView([lat, lng], 11);
          userLocationMarker.openPopup();

          locateBtn.disabled = false;
          locateBtn.textContent = "ë‚´ ìœ„ì¹˜ í‘œì‹œ";
          updateOffscreenIndicators(); // âœ¨ ë‚´ ìœ„ì¹˜ í‘œì‹œ í›„ ì§€í‘œë„ ì—…ë°ì´íŠ¸
          },
          error => {
          alert("ìœ„ì¹˜ ì •ë³´ë¥¼ ê°€ì ¸ì˜¤ëŠ” ë° ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤: " + error.message);
          locateBtn.disabled = false;
          locateBtn.textContent = "ë‚´ ìœ„ì¹˜ í‘œì‹œ";
          }
      );
      });

      // ë¡œì»¬ìŠ¤í† ë¦¬ì§€ ì €ì¥ í•¨ìˆ˜
      function saveSelectedToLocalStorage() {
      localStorage.setItem('selectedData', JSON.stringify(selectedData));
      }

      // ë¡œì»¬ìŠ¤í† ë¦¬ì§€ ë¶ˆëŸ¬ì˜¤ê¸° í•¨ìˆ˜
      function loadSelectedFromLocalStorage() {
      const stored = localStorage.getItem('selectedData');
      if (stored) {
          try {
          const parsed = JSON.parse(stored);
          if (Array.isArray(parsed)) {
              selectedData = parsed;
              renderSelected();
          }
          } catch (e) {
          console.error("ë¡œì»¬ìŠ¤í† ë¦¬ì§€ íŒŒì‹± ì˜¤ë¥˜", e);
          }
      }
      }

      // ì„ íƒ ë¦¬ìŠ¤íŠ¸ ì´ˆê¸°í™” ë²„íŠ¼
      document.getElementById('clear-selected').addEventListener('click', () => {
        if (confirm("ì„ íƒëœ ë¦¬ìŠ¤íŠ¸ë¥¼ ëª¨ë‘ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?")) {
            selectedData = [];
            renderSelected();
            localStorage.removeItem('selectedData');
            updateOffscreenIndicators(); // âœ¨ ì´ˆê¸°í™” í›„ ì§€í‘œë„ ì—…ë°ì´íŠ¸
        }
      });

      //ìˆ˜ì •ëœ add/removeSelected í•¨ìˆ˜(ë¡œì»¬ìŠ¤í† ë¦¬ì§€ ì €ì¥)
      function addSelected(row) {
        if (!selectedData.some(item => item.name === row.name && item.lat === row.lat && item.lng === row.lng)) {
            selectedData.push(row);
            renderSelected();
            saveSelectedToLocalStorage(); // ì €ì¥
        }
      }
      function removeSelected(idx) {
        selectedData.splice(idx, 1);
        renderSelected();
        saveSelectedToLocalStorage(); // ì €ì¥
      }

      // ê²€ìƒ‰ê²°ê³¼ ë¡œì»¬ìŠ¤í† ë¦¬ì§€ ì €ì¥
      function saveFullDataToLocalStorage() {
        localStorage.setItem('fullData', JSON.stringify(fullData));
      }

      // ê²€ìƒ‰ê²°ê³¼ ë¡œì»¬ìŠ¤í† ë¦¬ì§€ ë¶ˆëŸ¬ì˜¤ê¸°
      function loadFullDataFromLocalStorage() {
        const stored = localStorage.getItem('fullData');
        if (stored) {
          try {
            const parsed = JSON.parse(stored);
            if (Array.isArray(parsed)) {
              fullData = parsed;
              renderTable(fullData);
            }
          } catch (e) {
            console.error("fullData íŒŒì‹± ì˜¤ë¥˜", e);
          }
        }
      }

      // ê²€ìƒ‰ê²°ê³¼ ì´ˆê¸°í™” ë²„íŠ¼ ì´ë²¤íŠ¸
      document.getElementById('clear-search-result').addEventListener('click', () => {
        if (confirm("ê²€ìƒ‰ ê²°ê³¼ë¥¼ ì´ˆê¸°í™”í•˜ì‹œê² ìŠµë‹ˆê¹Œ?")) {
          fullData = [];
          renderTable(fullData);
          localStorage.removeItem('fullData');
        }
      });

      // ì—‘ì…€ ì—…ë¡œë“œ í›„ ë Œë”ë§ ë° ì €ì¥
      inputExcel.addEventListener('change', e => {
        const file = e.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = evt => {
          const data = new Uint8Array(evt.target.result);
          const workbook = XLSX.read(data, { type: 'array' });
          const firstSheetName = workbook.SheetNames[0];
          const worksheet = workbook.Sheets[firstSheetName];
          const jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1 });
          fullData = jsonData.slice(1).map(row => ({
            name: row[0] || '',
            address: row[1] || '',
            lat: row[2] !== undefined ? parseFloat(row[2]) || 0 : 0,
            lng: row[3] !== undefined ? parseFloat(row[3]) || 0 : 0
          }));
          renderTable(fullData);
          saveFullDataToLocalStorage();
        };
        reader.readAsArrayBuffer(file);
      });

      document.getElementById('select-all-search-results').addEventListener('click', () => {
        // í˜„ì¬ ì£¼ì†Œ í…Œì´ë¸”ì— ë³´ì´ëŠ” ë°ì´í„°(=ê²€ìƒ‰ê²°ê³¼) ê¸°ì¤€ìœ¼ë¡œ ì „ì²´ ì„ íƒ ë¦¬ìŠ¤íŠ¸ì— ì¶”ê°€
        const rows = tbody.querySelectorAll('tr');
        rows.forEach(tr => {
          const cells = tr.children;
          const rowData = {
            name: cells[0].textContent,
            address: cells[1].textContent,
            lat: parseFloat(cells[2].textContent), // ìœ„ë„ ë°ì´í„° ê°€ì ¸ì˜¤ê¸°
            lng: parseFloat(cells[3].textContent)  // ê²½ë„ ë°ì´í„° ê°€ì ¸ì˜¤ê¸°
          };
          // ì¤‘ë³µ í™•ì¸ í›„ ì¶”ê°€
          if (!selectedData.some(item => item.name === rowData.name && item.lat === rowData.lat && item.lng === rowData.lng)) {
            selectedData.push(rowData);
          }
        });
        renderSelected();
        saveSelectedToLocalStorage();
      });

      // âœ¨ APIì—ì„œ ë°ì´í„°ë¥¼ ê°€ì ¸ì˜¤ëŠ” í•¨ìˆ˜ ì¶”ê°€
      async function fetchCompaniesFromAPI() {
          const apiURL = 'http://jamdolyung90.dothome.co.kr/api/companies.php'; // ì‹¤ì œ API ì—”ë“œí¬ì¸íŠ¸ ì£¼ì†Œ
          loadingIndicator.textContent = 'APIì—ì„œ ë°ì´í„° ë¡œë”© ì¤‘...';
          loadingIndicator.style.display = 'block';

          try {
              const response = await fetch(apiURL);
              if (!response.ok) {
                  throw new Error(`HTTP error! status: ${response.status}`);
              }
              const result = await response.json();

              if (result.status === 'success') {
                  // APIì—ì„œ ê°€ì ¸ì˜¨ ë°ì´í„°ë¡œ fullDataë¥¼ ì—…ë°ì´íŠ¸í•©ë‹ˆë‹¤.
                  // API ì‘ë‹µ ë°ì´í„°ëŠ” DBì—ì„œ ê°€ì ¸ì˜¨ ê·¸ëŒ€ë¡œì´ë¯€ë¡œ, lat/lngë¥¼ floatìœ¼ë¡œ ë³€í™˜í•´ì¤ë‹ˆë‹¤.
                  fullData = result.data.map(item => ({
                      name: item.name,
                      address: item.address,
                      lat: parseFloat(item.latitude),
                      lng: parseFloat(item.longitude)
                  }));
                  renderTable(fullData);
                  saveFullDataToLocalStorage(); // ë¡œì»¬ ìŠ¤í† ë¦¬ì§€ì— ì €ì¥
                  alert(`APIì—ì„œ ${fullData.length}ê±´ì˜ ì—…ì²´ ëª©ë¡ì„ ì„±ê³µì ìœ¼ë¡œ ë¶ˆëŸ¬ì™”ìŠµë‹ˆë‹¤.`);
              } else {
                  alert(`API ì˜¤ë¥˜: ${result.message}`);
                  console.error('API Error:', result.message);
              }
          } catch (error) {
              alert('APIì—ì„œ ë°ì´í„°ë¥¼ ê°€ì ¸ì˜¤ëŠ” ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ' + error.message);
              console.error('Fetch Error:', error);
          } finally {
              loadingIndicator.style.display = 'none';
          }
      }

      // âœ¨ "APIì—ì„œ ì—…ì²´ ëª©ë¡ ê°€ì ¸ì˜¤ê¸°" ë²„íŠ¼ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì¶”ê°€
      loadFromApiBtn.addEventListener('click', fetchCompaniesFromAPI);


      window.addEventListener('DOMContentLoaded', () => {
        // ë¡œì»¬ìŠ¤í† ë¦¬ì§€ì—ì„œ ì„ íƒëœ ë¦¬ìŠ¤íŠ¸ ë° ì „ì²´ ë¦¬ìŠ¤íŠ¸ ë¶ˆëŸ¬ì˜¤ê¸°
        loadSelectedFromLocalStorage();
        loadFullDataFromLocalStorage();

        // ëª¨ë°”ì¼ ì—¬ë¶€ í™•ì¸ (ê°€ë¡œí­ 768px ì´í•˜)
        const isMobileDevice = window.innerWidth <= 768; // isMobile í•¨ìˆ˜ì™€ëŠ” ë³„ê°œë¡œ ì‚¬ìš© (ì´ˆê¸° ë¡œë“œ ì‹œ íŒë‹¨ìš©)
        let offscreenMarkersInitiallyVisible = false; // ì´ˆê¸° ì§€í‘œ í‘œì‹œ ì—¬ë¶€

        // 1. ë¡œì»¬ ìŠ¤í† ë¦¬ì§€ì—ì„œ ì´ì „ ì„¤ì • ë¶ˆëŸ¬ì˜¤ê¸°
        const storedVisibility = localStorage.getItem('offscreenMarkersVisible');
        if (storedVisibility !== null) {
            offscreenMarkersInitiallyVisible = (storedVisibility === 'true');
        } else {
            // 2. ë¡œì»¬ ìŠ¤í† ë¦¬ì§€ì— ì„¤ì •ì´ ì—†ìœ¼ë©´ í™˜ê²½ì— ë”°ë¼ ê¸°ë³¸ê°’ ì„¤ì •
            offscreenMarkersInitiallyVisible = !isMobileDevice; // PCë©´ ë³´ì´ê¸°, ëª¨ë°”ì¼ì´ë©´ ìˆ¨ê¸°ê¸°
        }

        // 3. offscreen-indicators-container ì´ˆê¸° ìƒíƒœ ì„¤ì •
        if (offscreenMarkersInitiallyVisible) {
            offscreenIndicatorsContainer.style.display = 'block';
            toggleOffscreenMarkersBtn.textContent = 'í™”ë©´ ë°– ë§ˆì»¤ ìˆ¨ê¸°ê¸°';
        } else {
            offscreenIndicatorsContainer.style.display = 'none';
            toggleOffscreenMarkersBtn.textContent = 'í™”ë©´ ë°– ë§ˆì»¤ í‘œì‹œ';
        }


        // ëª¨ë°”ì¼ì´ê³  ìœ„ì¹˜ ì •ë³´ ì‚¬ìš© ê°€ëŠ¥í•˜ë©´
        if (isMobileDevice && navigator.geolocation) { // isMobileDevice ë³€ìˆ˜ ì‚¬ìš©
          navigator.geolocation.getCurrentPosition(
            position => {
              // í˜„ì¬ ìœ„ì¹˜ ì¢Œí‘œ ë°›ì•„ì˜¤ê¸°
              const lat = position.coords.latitude;
              const lng = position.coords.longitude;

              // ì§€ë„ ì¤‘ì‹¬ì„ ë‚´ ìœ„ì¹˜ë¡œ ì„¤ì •
              map.setView([lat, lng], 11);

              // ì§€ë„ê°€ ë³´ì´ë„ë¡ ê°•ì œë¡œ í¬ê¸° ì¬ê³„ì‚°
              map.whenReady(() => {
                map.invalidateSize();
                updateOffscreenIndicators(); // âœ¨ ì´ˆê¸° ë¡œë“œ ì‹œ ì§€í‘œ ì—…ë°ì´íŠ¸
              });

              // ë‚´ ìœ„ì¹˜ ë§ˆì»¤ê°€ ì´ë¯¸ ìˆìœ¼ë©´ ìœ„ì¹˜ë§Œ ì´ë™, ì—†ìœ¼ë©´ ìƒˆë¡œ ìƒì„±
              if (userLocationMarker) {
                userLocationMarker.setLatLng([lat, lng]);
              } else {
                userLocationMarker = L.marker([lat, lng], {
                  title: "ë‚´ ìœ„ì¹˜",
                  icon: L.divIcon({
                    className: '',
                    html: `<div style="
                      width: 24px;
                      height: 24px;
                      background: blue;
                      border: 3px solid white;
                      border-radius: 50%;
                      box-shadow: 0 0 8px 2px rgba(0,0,255,0.7);
                    "></div>`,
                    iconSize: [30, 30],
                    iconAnchor: [15, 15],
                    popupAnchor: [0, -15]
                  })
                }).addTo(map).bindPopup("ë‚´ ìœ„ì¹˜").openPopup();
              }
            },
            error => {
              // ìœ„ì¹˜ ì •ë³´ë¥¼ ê°€ì ¸ì˜¤ëŠ” ë° ì‹¤íŒ¨í•˜ë©´ ë‚´ íšŒì‚¬ ìœ„ì¹˜ë¡œ ì´ë™
              console.warn("GPS ì‹¤íŒ¨: ë‚´ íšŒì‚¬ ìœ„ì¹˜ë¡œ ì´ˆê¸°í™”");
              map.setView([myCompany.lat, myCompany.lng], 11);
              map.whenReady(() => {
                map.invalidateSize();
                updateOffscreenIndicators(); // âœ¨ ì´ˆê¸° ë¡œë“œ ì‹œ ì§€í‘œ ì—…ë°ì´íŠ¸
              });
            }
          );
        } else {
          // ë°ìŠ¤í¬íƒ‘ì´ê±°ë‚˜ GPS ë¯¸ì§€ì›ì¸ ê²½ìš° ë‚´ íšŒì‚¬ ìœ„ì¹˜ë¡œ ì´ˆê¸°í™”
          map.setView([myCompany.lat, myCompany.lng], 11);
          map.whenReady(() => {
            map.invalidateSize();
            updateOffscreenIndicators(); // âœ¨ ì´ˆê¸° ë¡œë“œ ì‹œ ì§€í‘œ ì—…ë°ì´íŠ¸
          });
        }
      });

      // âœ¨ í™”ë©´ í¬ê¸°ê°€ ë³€ê²½ë  ë•Œë§ˆë‹¤ ì§€ë„ í¬ê¸°ë¥¼ ë‹¤ì‹œ ê³„ì‚°í•˜ì—¬ ì˜¬ë°”ë¥´ê²Œ í‘œì‹œë˜ë„ë¡ í•¨
      window.addEventListener('resize', function() {
          map.invalidateSize();
          updateOffscreenIndicators(); // âœ¨ í™”ë©´ ë¦¬ì‚¬ì´ì¦ˆ ì‹œ ì§€í‘œë„ ì—…ë°ì´íŠ¸
      });
  </script>


</body>
</html>